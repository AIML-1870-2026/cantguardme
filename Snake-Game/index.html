<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Ultimate</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Main Menu Styles */
        #mainMenu {
            text-align: center;
            padding: 40px 20px;
        }

        .game-title {
            font-size: 4em;
            font-weight: bold;
            background: linear-gradient(90deg, #00ff88, #00ccff, #ff8800, #00ff88);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
            margin-bottom: 10px;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .player-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            min-width: 150px;
        }

        .stat-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #00ff88;
        }

        .xp-bar-container {
            width: 100%;
            max-width: 400px;
            margin: 0 auto 30px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 5px;
            border: 2px solid #00ccff;
        }

        .xp-bar {
            height: 20px;
            background: linear-gradient(90deg, #00ff88, #00ccff);
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .xp-text {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 5px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            margin-top: 30px;
        }

        .menu-btn {
            padding: 15px 40px;
            font-size: 1.2em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 280px;
            font-weight: bold;
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #00ccff, #0099cc);
            color: #000;
        }

        .menu-btn.tertiary {
            background: linear-gradient(135deg, #ff8800, #cc6600);
            color: #000;
        }

        .menu-btn.quaternary {
            background: linear-gradient(135deg, #9b59b6, #7d3c98);
            color: #fff;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .menu-btn:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .unlock-preview {
            margin-top: 40px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid #ff8800;
        }

        .unlock-preview h3 {
            color: #ff8800;
            margin-bottom: 10px;
        }

        /* Customization Button */
        .customize-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: linear-gradient(135deg, #e91e63, #9c27b0);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .customize-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(233, 30, 99, 0.5);
        }

        /* Game Screen Styles */
        #gameScreen {
            display: none;
        }

        .game-layout {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
        }

        .game-canvas-container {
            position: relative;
        }

        #gameCanvas {
            border: 3px solid #00ff88;
            border-radius: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #particleCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #trailCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .game-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ccff;
            min-width: 200px;
        }

        .info-item {
            margin-bottom: 15px;
        }

        .info-label {
            font-size: 0.9em;
            color: #888;
        }

        .info-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #00ff88;
        }

        .power-ups-display {
            margin-top: 20px;
        }

        .power-up-active {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(0, 255, 136, 0.2);
            border-radius: 5px;
            margin-bottom: 8px;
        }

        .power-up-icon {
            font-size: 1.5em;
        }

        .power-up-timer {
            font-size: 0.9em;
            color: #00ff88;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .control-btn.pause {
            background: #ff8800;
            color: #000;
        }

        .control-btn.quit {
            background: #ff4444;
            color: #fff;
        }

        .control-btn:hover {
            transform: scale(1.05);
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #00ff88;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.5);
        }

        .modal-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 2em;
            color: #00ff88;
            margin-bottom: 20px;
        }

        .modal-text {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 30px;
            color: #ccc;
        }

        .modal-btn {
            padding: 15px 40px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: #00ff88;
            color: #000;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .modal-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .skip-tutorials {
            margin-top: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: #888;
        }

        /* Customization Modal */
        .skin-grid, .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .skin-option, .theme-option {
            padding: 15px;
            border-radius: 10px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(0, 0, 0, 0.3);
        }

        .skin-option:hover, .theme-option:hover {
            border-color: #00ccff;
        }

        .skin-option.selected, .theme-option.selected {
            border-color: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .skin-option.locked, .theme-option.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skin-preview {
            width: 80px;
            height: 20px;
            margin: 10px auto;
            border-radius: 10px;
        }

        .skin-name {
            font-weight: bold;
            margin-top: 5px;
        }

        .unlock-level {
            font-size: 0.8em;
            color: #ff8800;
        }

        /* Game Over Screen */
        .game-over-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff4444;
            max-width: 400px;
            text-align: center;
        }

        .game-over-title {
            font-size: 2.5em;
            color: #ff4444;
            margin-bottom: 20px;
        }

        .game-over-stats {
            margin: 30px 0;
        }

        .game-over-stat {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            margin-bottom: 10px;
        }

        /* Level Up Screen */
        .level-up-content {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #ff8800;
            max-width: 500px;
            text-align: center;
            animation: levelUpPulse 0.5s ease;
        }

        @keyframes levelUpPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .level-up-title {
            font-size: 2.5em;
            color: #ff8800;
            margin-bottom: 20px;
        }

        .unlock-item {
            background: rgba(0, 255, 136, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #00ff88;
        }

        /* Notification Toast */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            animation: slideIn 0.5s ease;
            z-index: 2000;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* AI/2Player Mode Selection */
        .mode-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .mode-option {
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #00ccff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-option:hover, .mode-option.selected {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
        }

        /* Level Editor */
        #editorScreen {
            display: none;
            padding: 20px;
        }

        .editor-toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .editor-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .editor-btn.active {
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        #editorCanvas {
            background: #000;
            border: 3px solid #00ff88;
            border-radius: 5px;
            cursor: crosshair;
        }

        .level-code-container {
            margin-top: 20px;
            text-align: center;
        }

        .level-code-input {
            width: 100%;
            max-width: 400px;
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #00ccff;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-family: monospace;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            justify-content: center;
            gap: 5px;
            margin-top: 20px;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            font-size: 1.5em;
            border: none;
            border-radius: 10px;
            background: rgba(0, 255, 136, 0.3);
            color: white;
            cursor: pointer;
        }

        .mobile-dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
        }

        .mobile-dpad .mobile-btn:nth-child(1) { grid-column: 2; grid-row: 1; }
        .mobile-dpad .mobile-btn:nth-child(2) { grid-column: 1; grid-row: 2; }
        .mobile-dpad .mobile-btn:nth-child(3) { grid-column: 3; grid-row: 2; }
        .mobile-dpad .mobile-btn:nth-child(4) { grid-column: 2; grid-row: 3; }

        @media (max-width: 768px) {
            .game-title { font-size: 2.5em; }
            .game-layout { flex-direction: column; align-items: center; }
            #gameCanvas, #particleCanvas, #trailCanvas { width: 320px !important; height: 320px !important; }
            .mobile-controls { display: flex; }
            .skin-grid, .theme-grid { grid-template-columns: repeat(2, 1fr); }
        }

        /* Pause overlay */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 3em;
            color: #00ff88;
            border-radius: 5px;
        }

        /* Dash cooldown indicator */
        .dash-indicator {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }

        .dash-bar {
            height: 100%;
            background: linear-gradient(90deg, #ffff00, #ff8800);
            transition: width 0.1s linear;
        }

        /* Current Skin Display */
        .current-skin-display {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid #9b59b6;
        }

        .current-skin-preview {
            height: 30px;
            border-radius: 15px;
            margin: 10px auto;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="mainMenu" class="container">
        <h1 class="game-title">SNAKE ULTIMATE</h1>
        <p style="color: #aaa; margin-bottom: 20px;">The Ultimate Progressive Snake Experience</p>

        <div class="player-stats">
            <div class="stat-box">
                <div class="stat-label">LEVEL</div>
                <div class="stat-value" id="menuLevel">1</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">HIGH SCORE</div>
                <div class="stat-value" id="menuHighScore">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">COINS</div>
                <div class="stat-value" id="menuCoins">0</div>
            </div>
        </div>

        <div class="xp-bar-container">
            <div class="xp-bar" id="menuXpBar" style="width: 0%"></div>
        </div>
        <div class="xp-text" id="menuXpText">0 / 100 XP to Level 2</div>

        <div class="current-skin-display">
            <div class="stat-label">CURRENT SKIN</div>
            <div class="current-skin-preview" id="currentSkinPreview"></div>
            <button class="customize-btn" onclick="openCustomization()">Customize Snake</button>
        </div>

        <div class="menu-buttons">
            <button class="menu-btn primary" onclick="startGame('classic')">Classic Mode</button>
            <button class="menu-btn secondary" onclick="startGame('twoPlayer')">Two Player Mode</button>
            <button class="menu-btn tertiary" onclick="showAISelection()">AI Opponent</button>
            <button class="menu-btn quaternary" onclick="openEditor()">Level Editor</button>
            <button class="menu-btn" style="background: #444;" id="timeAttackBtn" onclick="startGame('timeAttack')" disabled>Time Attack (Lvl 13)</button>
            <button class="menu-btn" style="background: #444;" id="survivalBtn" onclick="startGame('survival')" disabled>Survival Mode (Lvl 17)</button>
        </div>

        <div class="unlock-preview" id="unlockPreview">
            <h3>Next Unlock</h3>
            <p id="nextUnlockText">Speed Boost Power-Up at Level 2</p>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen" class="container">
        <div class="game-layout">
            <div class="game-canvas-container" id="canvasContainer">
                <canvas id="trailCanvas" width="600" height="600"></canvas>
                <canvas id="gameCanvas" width="600" height="600"></canvas>
                <canvas id="particleCanvas" width="600" height="600"></canvas>
                <div class="pause-overlay" id="pauseOverlay">PAUSED</div>
            </div>

            <div class="game-info">
                <div class="info-item">
                    <div class="info-label">SCORE</div>
                    <div class="info-value" id="scoreDisplay">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">HIGH SCORE</div>
                    <div class="info-value" id="highScoreDisplay">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">LENGTH</div>
                    <div class="info-value" id="lengthDisplay">3</div>
                </div>
                <div class="info-item">
                    <div class="info-label">COMBO</div>
                    <div class="info-value" id="comboDisplay">1x</div>
                </div>
                <div class="info-item" id="timerItem" style="display: none;">
                    <div class="info-label">TIME</div>
                    <div class="info-value" id="timerDisplay">60</div>
                </div>

                <div class="power-ups-display" id="powerUpsDisplay"></div>

                <div id="dashContainer" style="display: none;">
                    <div class="info-label">DASH (SPACE)</div>
                    <div class="dash-indicator">
                        <div class="dash-bar" id="dashBar" style="width: 100%"></div>
                    </div>
                </div>

                <div class="game-controls">
                    <button class="control-btn pause" onclick="togglePause()">Pause</button>
                    <button class="control-btn quit" onclick="quitGame()">Quit</button>
                </div>
            </div>
        </div>

        <div class="mobile-controls">
            <div class="mobile-dpad">
                <button class="mobile-btn" onclick="setDirection('up')">‚Üë</button>
                <button class="mobile-btn" onclick="setDirection('left')">‚Üê</button>
                <button class="mobile-btn" onclick="setDirection('right')">‚Üí</button>
                <button class="mobile-btn" onclick="setDirection('down')">‚Üì</button>
            </div>
            <button class="mobile-btn" id="dashBtn" onclick="doDash()" style="margin-left: 20px; display: none;">‚ö°</button>
        </div>
    </div>

    <!-- Level Editor -->
    <div id="editorScreen" class="container">
        <h2 style="text-align: center; margin-bottom: 20px;">Level Editor</h2>
        <div class="editor-toolbar">
            <button class="editor-btn active" id="wallTool" onclick="setEditorTool('wall')" style="background: #00ff88; color: #000;">Place Wall</button>
            <button class="editor-btn" id="eraseTool" onclick="setEditorTool('erase')" style="background: #ff4444; color: #fff;">Erase</button>
            <button class="editor-btn" onclick="clearEditor()" style="background: #ff8800; color: #000;">Clear All</button>
            <button class="editor-btn" onclick="testLevel()" style="background: #00ccff; color: #000;">Test Level</button>
            <button class="editor-btn" onclick="saveLevel()" style="background: #9b59b6; color: #fff;">Save Code</button>
            <button class="editor-btn" onclick="loadLevel()" style="background: #27ae60; color: #fff;">Load Code</button>
            <button class="editor-btn" onclick="closeEditor()" style="background: #444; color: #fff;">Back to Menu</button>
        </div>
        <div style="text-align: center;">
            <canvas id="editorCanvas" width="600" height="600"></canvas>
        </div>
        <div class="level-code-container">
            <input type="text" class="level-code-input" id="levelCodeInput" placeholder="Level code will appear here...">
        </div>
    </div>

    <!-- Tutorial Modal -->
    <div class="modal-overlay" id="tutorialModal">
        <div class="modal-content">
            <div class="modal-icon" id="tutorialIcon"></div>
            <h2 class="modal-title" id="tutorialTitle"></h2>
            <p class="modal-text" id="tutorialText"></p>
            <button class="modal-btn" onclick="closeTutorial()">Got it!</button>
            <div class="skip-tutorials">
                <input type="checkbox" id="skipTutorials" onchange="toggleSkipTutorials()">
                <label for="skipTutorials">Skip all tutorials</label>
            </div>
        </div>
    </div>

    <!-- Customization Modal -->
    <div class="modal-overlay" id="customizeModal">
        <div class="modal-content">
            <h2 class="modal-title">Customize Your Snake</h2>

            <h3 style="color: #00ccff; margin: 20px 0 10px;">Snake Skins</h3>
            <div class="skin-grid" id="skinGrid"></div>

            <h3 style="color: #00ccff; margin: 20px 0 10px;">Game Themes</h3>
            <div class="theme-grid" id="themeGrid"></div>

            <button class="modal-btn" style="margin-top: 20px;" onclick="closeCustomization()">Done</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal-overlay" id="gameOverModal">
        <div class="game-over-content">
            <h2 class="game-over-title" id="gameOverTitle">GAME OVER</h2>
            <div class="game-over-stats">
                <div class="game-over-stat">
                    <span>Score</span>
                    <span id="finalScore">0</span>
                </div>
                <div class="game-over-stat">
                    <span>Length</span>
                    <span id="finalLength">3</span>
                </div>
                <div class="game-over-stat">
                    <span>XP Earned</span>
                    <span id="xpEarned">0</span>
                </div>
                <div class="game-over-stat">
                    <span>Coins Earned</span>
                    <span id="coinsEarned">0</span>
                </div>
            </div>
            <button class="modal-btn" onclick="closeGameOver()">Continue</button>
        </div>
    </div>

    <!-- Level Up Modal -->
    <div class="modal-overlay" id="levelUpModal">
        <div class="level-up-content">
            <h2 class="level-up-title">LEVEL UP!</h2>
            <p style="font-size: 3em; margin: 20px 0;" id="newLevelDisplay">2</p>
            <div class="unlock-item" id="levelUpUnlock"></div>
            <button class="modal-btn" onclick="closeLevelUp()">Awesome!</button>
        </div>
    </div>

    <!-- AI Selection Modal -->
    <div class="modal-overlay" id="aiModal">
        <div class="modal-content">
            <h2 class="modal-title">Select AI Difficulty</h2>
            <div class="mode-selection">
                <div class="mode-option" onclick="startGame('ai', 'easy')">
                    <h3>Easy</h3>
                    <p style="color: #888;">Slow reactions</p>
                </div>
                <div class="mode-option" onclick="startGame('ai', 'medium')">
                    <h3>Medium</h3>
                    <p style="color: #888;">Balanced play</p>
                </div>
                <div class="mode-option" onclick="startGame('ai', 'hard')">
                    <h3>Hard</h3>
                    <p style="color: #888;">Expert AI</p>
                </div>
            </div>
            <button class="modal-btn" style="background: #ff4444; margin-top: 20px;" onclick="closeAIModal()">Cancel</button>
        </div>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const CELL_SIZE = 20;
        const GRID_SIZE = 30;
        const CANVAS_SIZE = 600;

        // ==================== SNAKE SKINS ====================
        const SNAKE_SKINS = {
            classic: {
                name: 'Classic',
                unlockLevel: 1,
                colors: ['#00ff88', '#00dd77', '#00bb66'],
                glow: '#00ff88',
                pattern: 'solid',
                trail: false
            },
            neon: {
                name: 'Neon Pulse',
                unlockLevel: 3,
                colors: ['#00ffff', '#00ddff', '#00bbff'],
                glow: '#00ffff',
                pattern: 'pulse',
                trail: true,
                trailColor: 'rgba(0, 255, 255, 0.3)'
            },
            fire: {
                name: 'Inferno',
                unlockLevel: 5,
                colors: ['#ff4400', '#ff6600', '#ff8800'],
                glow: '#ff4400',
                pattern: 'gradient',
                trail: true,
                trailColor: 'rgba(255, 68, 0, 0.3)'
            },
            rainbow: {
                name: 'Rainbow',
                unlockLevel: 7,
                colors: ['#ff0000', '#ff7700', '#ffff00', '#00ff00', '#0000ff', '#8b00ff'],
                glow: '#ffffff',
                pattern: 'rainbow',
                trail: true,
                trailColor: 'rgba(255, 255, 255, 0.2)'
            },
            galaxy: {
                name: 'Galaxy',
                unlockLevel: 10,
                colors: ['#9b59b6', '#8e44ad', '#6c3483'],
                glow: '#9b59b6',
                pattern: 'sparkle',
                trail: true,
                trailColor: 'rgba(155, 89, 182, 0.4)'
            },
            ice: {
                name: 'Frost',
                unlockLevel: 12,
                colors: ['#a8e6cf', '#88d8b0', '#56ab91'],
                glow: '#a8e6cf',
                pattern: 'shimmer',
                trail: true,
                trailColor: 'rgba(168, 230, 207, 0.3)'
            },
            gold: {
                name: 'Golden',
                unlockLevel: 15,
                colors: ['#ffd700', '#ffcc00', '#ffaa00'],
                glow: '#ffd700',
                pattern: 'metallic',
                trail: true,
                trailColor: 'rgba(255, 215, 0, 0.4)'
            },
            void: {
                name: 'Void Walker',
                unlockLevel: 18,
                colors: ['#1a1a2e', '#16213e', '#0f3460'],
                glow: '#e94560',
                pattern: 'void',
                trail: true,
                trailColor: 'rgba(233, 69, 96, 0.5)'
            },
            plasma: {
                name: 'Plasma',
                unlockLevel: 20,
                colors: ['#ff00ff', '#ff00aa', '#aa00ff'],
                glow: '#ff00ff',
                pattern: 'plasma',
                trail: true,
                trailColor: 'rgba(255, 0, 255, 0.4)'
            }
        };

        // ==================== GAME THEMES ====================
        const GAME_THEMES = {
            classic: {
                name: 'Classic',
                unlockLevel: 1,
                background: '#000000',
                gridColor: '#111111',
                borderColor: '#00ff88'
            },
            midnight: {
                name: 'Midnight',
                unlockLevel: 4,
                background: '#0d1b2a',
                gridColor: '#1b263b',
                borderColor: '#00ccff'
            },
            sunset: {
                name: 'Sunset',
                unlockLevel: 6,
                background: '#2d132c',
                gridColor: '#3d1a3d',
                borderColor: '#ff8800'
            },
            forest: {
                name: 'Forest',
                unlockLevel: 8,
                background: '#1a2f1a',
                gridColor: '#2a3f2a',
                borderColor: '#00ff44'
            },
            ocean: {
                name: 'Ocean',
                unlockLevel: 11,
                background: '#0a1628',
                gridColor: '#142238',
                borderColor: '#00ddff'
            },
            lava: {
                name: 'Lava',
                unlockLevel: 14,
                background: '#1a0a0a',
                gridColor: '#2a1515',
                borderColor: '#ff4400'
            },
            aurora: {
                name: 'Aurora',
                unlockLevel: 16,
                background: '#0f0c29',
                gridColor: '#1a1640',
                borderColor: '#00ff88'
            },
            cosmic: {
                name: 'Cosmic',
                unlockLevel: 19,
                background: '#0a0a1a',
                gridColor: '#151530',
                borderColor: '#9b59b6'
            }
        };

        // ==================== GAME STATE ====================
        let gameState = {
            // Player Progress
            playerLevel: 1,
            xp: 0,
            coins: 0,
            highScore: 0,
            unlockedFeatures: ['basic'],
            tutorialsShown: [],
            skipTutorials: false,
            currentSkin: 'classic',
            currentTheme: 'classic',

            // Snake state with smooth animation
            snake: [],
            snakePositions: [], // For smooth interpolation
            snake2: [],
            aiSnake: [],
            direction: { x: 1, y: 0 },
            direction2: { x: -1, y: 0 },
            aiDirection: { x: -1, y: 0 },
            nextDirection: null,
            nextDirection2: null,

            // Game objects
            food: null,
            powerUps: [],
            obstacles: [],
            portals: [],
            particles: [],
            trailPoints: [],

            // Scores
            score: 0,
            score2: 0,
            aiScore: 0,
            combo: 1,
            lastFoodType: null,

            // Game status
            gameRunning: false,
            gamePaused: false,
            gameMode: 'classic',
            aiDifficulty: 'medium',

            // Animation
            animationProgress: 0,
            lastUpdateTime: 0,
            pulsePhase: 0,

            // Power-ups
            speedBoost: false,
            speedBoostTimer: 0,
            shield: false,
            scoreMultiplier: false,
            scoreMultiplierTimer: 0,
            ghostMode: false,
            ghostModeTimer: 0,
            magnetMode: false,
            magnetModeTimer: 0,

            // Dash
            dashCooldown: 0,
            dashReady: true,

            // Modes
            timeRemaining: 60,
            arenaSize: 30,

            // Editor
            editorWalls: [],
            editorTool: 'wall',
            customWalls: [],

            // Speed
            baseSpeed: 100,
            currentSpeed: 100
        };

        // Level requirements
        const LEVEL_XP = [0, 100, 250, 450, 700, 1000, 1400, 1900, 2500, 3200, 4000, 4900, 5900, 7000, 8500, 10200, 12100, 14200, 16500, 19000];

        const LEVEL_UNLOCKS = {
            2: { name: 'Speed Boost', icon: '‚ö°', desc: 'Collect yellow lightning for temporary speed boost (5 sec)' },
            3: { name: 'Neon Pulse Skin', icon: 'üé®', desc: 'A glowing cyan snake with pulsing effects!' },
            4: { name: 'Midnight Theme', icon: 'üåô', desc: 'A dark blue aesthetic for night owls' },
            5: { name: 'Inferno Skin', icon: 'üî•', desc: 'A fiery orange snake that leaves flame trails!' },
            6: { name: 'Sunset Theme', icon: 'üåÖ', desc: 'Warm purple hues for a cozy vibe' },
            7: { name: 'Rainbow Skin', icon: 'üåà', desc: 'A magnificent color-shifting snake!' },
            8: { name: 'Forest Theme', icon: 'üå≤', desc: 'Deep greens of an enchanted forest' },
            9: { name: 'Magnet', icon: 'üß≤', desc: 'Attracts nearby food toward you!' },
            10: { name: 'Galaxy Skin', icon: '‚ú®', desc: 'Cosmic purple with sparkling stars!' },
            11: { name: 'Ocean Theme', icon: 'üåä', desc: 'Deep sea blues and teals' },
            12: { name: 'Frost Skin', icon: '‚ùÑÔ∏è', desc: 'Icy cool with shimmering effects!' },
            13: { name: 'Time Attack', icon: '‚è±Ô∏è', desc: '60 seconds to maximize your score!' },
            14: { name: 'Lava Theme', icon: 'üåã', desc: 'Hot reds and oranges!' },
            15: { name: 'Golden Skin', icon: 'üëë', desc: 'Majestic golden snake with metallic shine!' },
            16: { name: 'Aurora Theme', icon: 'üåå', desc: 'Northern lights inspired colors' },
            17: { name: 'Survival Mode', icon: 'üíÄ', desc: 'The arena shrinks over time!' },
            18: { name: 'Void Walker Skin', icon: 'üï≥Ô∏è', desc: 'Dark matter with glowing edges!' },
            19: { name: 'Cosmic Theme', icon: 'ü™ê', desc: 'Deep space purple aesthetic' },
            20: { name: 'Plasma Skin', icon: '‚ö°', desc: 'Ultimate plasma energy snake!' }
        };

        // Tutorials
        const TUTORIALS = {
            welcome: { icon: 'üëã', title: 'WELCOME TO SNAKE ULTIMATE!', text: 'Use arrow keys or WASD to control your snake.\nEat red apples to grow and score points.\nAvoid walls and your own body!' },
            twoPlayer: { icon: 'üë•', title: 'TWO PLAYER MODE', text: 'Player 1: Arrow Keys\nPlayer 2: IJKL\nFirst to 200 points or last one standing wins!' },
            aiMode: { icon: 'ü§ñ', title: 'AI OPPONENT', text: 'Compete against an AI snake!\nFirst to 200 points wins.\nChoose your difficulty!' },
            editor: { icon: 'üé®', title: 'LEVEL EDITOR', text: 'Click to place walls, right-click to erase.\nTest your creation and share level codes!' }
        };

        // Canvas contexts
        let canvas, ctx, particleCanvas, particleCtx, trailCanvas, trailCtx, editorCanvas, editorCtx;
        let gameLoop, renderLoop;

        // ==================== INITIALIZATION ====================
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            particleCanvas = document.getElementById('particleCanvas');
            particleCtx = particleCanvas.getContext('2d');
            trailCanvas = document.getElementById('trailCanvas');
            trailCtx = trailCanvas.getContext('2d');
            editorCanvas = document.getElementById('editorCanvas');
            editorCtx = editorCanvas.getContext('2d');

            loadProgress();
            updateMenuDisplay();
            updateSkinPreview();
            setupControls();
            setupEditorControls();

            if (!gameState.tutorialsShown.includes('welcome') && !gameState.skipTutorials) {
                showTutorial('welcome');
            }
        }

        function loadProgress() {
            const saved = localStorage.getItem('snakeUltimateProgress');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.playerLevel = data.playerLevel || 1;
                gameState.xp = data.xp || 0;
                gameState.coins = data.coins || 0;
                gameState.highScore = data.highScore || 0;
                gameState.unlockedFeatures = data.unlockedFeatures || ['basic'];
                gameState.tutorialsShown = data.tutorialsShown || [];
                gameState.skipTutorials = data.skipTutorials || false;
                gameState.currentSkin = data.currentSkin || 'classic';
                gameState.currentTheme = data.currentTheme || 'classic';
            }
        }

        function saveProgress() {
            const data = {
                playerLevel: gameState.playerLevel,
                xp: gameState.xp,
                coins: gameState.coins,
                highScore: gameState.highScore,
                unlockedFeatures: gameState.unlockedFeatures,
                tutorialsShown: gameState.tutorialsShown,
                skipTutorials: gameState.skipTutorials,
                currentSkin: gameState.currentSkin,
                currentTheme: gameState.currentTheme
            };
            localStorage.setItem('snakeUltimateProgress', JSON.stringify(data));
        }

        function updateMenuDisplay() {
            document.getElementById('menuLevel').textContent = gameState.playerLevel;
            document.getElementById('menuHighScore').textContent = gameState.highScore;
            document.getElementById('menuCoins').textContent = gameState.coins;

            const currentLevelXp = LEVEL_XP[gameState.playerLevel - 1] || 0;
            const nextLevelXp = LEVEL_XP[gameState.playerLevel] || LEVEL_XP[LEVEL_XP.length - 1];
            const xpProgress = ((gameState.xp - currentLevelXp) / (nextLevelXp - currentLevelXp)) * 100;
            document.getElementById('menuXpBar').style.width = Math.min(100, Math.max(0, xpProgress)) + '%';
            document.getElementById('menuXpText').textContent = `${gameState.xp} / ${nextLevelXp} XP to Level ${gameState.playerLevel + 1}`;

            const nextUnlock = LEVEL_UNLOCKS[gameState.playerLevel + 1];
            if (nextUnlock) {
                document.getElementById('nextUnlockText').textContent = `${nextUnlock.icon} ${nextUnlock.name} at Level ${gameState.playerLevel + 1}`;
            } else {
                document.getElementById('nextUnlockText').textContent = 'All features unlocked!';
            }

            document.getElementById('timeAttackBtn').disabled = gameState.playerLevel < 13;
            document.getElementById('survivalBtn').disabled = gameState.playerLevel < 17;
            if (gameState.playerLevel >= 13) {
                document.getElementById('timeAttackBtn').style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                document.getElementById('timeAttackBtn').textContent = 'Time Attack Mode';
            }
            if (gameState.playerLevel >= 17) {
                document.getElementById('survivalBtn').style.background = 'linear-gradient(135deg, #2c3e50, #1a252f)';
                document.getElementById('survivalBtn').textContent = 'Survival Mode';
            }
        }

        function updateSkinPreview() {
            const skin = SNAKE_SKINS[gameState.currentSkin];
            const preview = document.getElementById('currentSkinPreview');
            if (skin.pattern === 'rainbow') {
                preview.style.background = 'linear-gradient(90deg, #ff0000, #ff7700, #ffff00, #00ff00, #0000ff, #8b00ff)';
            } else {
                preview.style.background = `linear-gradient(90deg, ${skin.colors.join(', ')})`;
            }
            preview.style.boxShadow = `0 0 15px ${skin.glow}`;
        }

        // ==================== CUSTOMIZATION ====================
        function openCustomization() {
            renderSkinGrid();
            renderThemeGrid();
            document.getElementById('customizeModal').style.display = 'flex';
        }

        function closeCustomization() {
            document.getElementById('customizeModal').style.display = 'none';
            updateSkinPreview();
            saveProgress();
        }

        function renderSkinGrid() {
            const grid = document.getElementById('skinGrid');
            grid.innerHTML = '';

            Object.entries(SNAKE_SKINS).forEach(([id, skin]) => {
                const isUnlocked = gameState.playerLevel >= skin.unlockLevel;
                const isSelected = gameState.currentSkin === id;

                const div = document.createElement('div');
                div.className = `skin-option ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}`;

                let bgStyle;
                if (skin.pattern === 'rainbow') {
                    bgStyle = 'linear-gradient(90deg, #ff0000, #ff7700, #ffff00, #00ff00, #0000ff, #8b00ff)';
                } else {
                    bgStyle = `linear-gradient(90deg, ${skin.colors.join(', ')})`;
                }

                div.innerHTML = `
                    <div class="skin-preview" style="background: ${bgStyle}; box-shadow: 0 0 10px ${skin.glow};"></div>
                    <div class="skin-name">${skin.name}</div>
                    ${!isUnlocked ? `<div class="unlock-level">Unlocks at Lvl ${skin.unlockLevel}</div>` : ''}
                `;

                if (isUnlocked) {
                    div.onclick = () => selectSkin(id);
                }

                grid.appendChild(div);
            });
        }

        function renderThemeGrid() {
            const grid = document.getElementById('themeGrid');
            grid.innerHTML = '';

            Object.entries(GAME_THEMES).forEach(([id, theme]) => {
                const isUnlocked = gameState.playerLevel >= theme.unlockLevel;
                const isSelected = gameState.currentTheme === id;

                const div = document.createElement('div');
                div.className = `theme-option ${isSelected ? 'selected' : ''} ${!isUnlocked ? 'locked' : ''}`;

                div.innerHTML = `
                    <div style="width: 80px; height: 50px; margin: 0 auto; background: ${theme.background}; border: 3px solid ${theme.borderColor}; border-radius: 5px;">
                        <div style="width: 100%; height: 100%; background: repeating-linear-gradient(90deg, ${theme.gridColor} 0px, ${theme.gridColor} 1px, transparent 1px, transparent 10px);"></div>
                    </div>
                    <div class="skin-name">${theme.name}</div>
                    ${!isUnlocked ? `<div class="unlock-level">Unlocks at Lvl ${theme.unlockLevel}</div>` : ''}
                `;

                if (isUnlocked) {
                    div.onclick = () => selectTheme(id);
                }

                grid.appendChild(div);
            });
        }

        function selectSkin(skinId) {
            gameState.currentSkin = skinId;
            renderSkinGrid();
            showToast(`${SNAKE_SKINS[skinId].name} skin selected!`);
        }

        function selectTheme(themeId) {
            gameState.currentTheme = themeId;
            renderThemeGrid();
            showToast(`${GAME_THEMES[themeId].name} theme selected!`);
        }

        // ==================== CONTROLS ====================
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                if (!gameState.gameRunning) return;

                if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                    if (gameState.direction.y !== 1) gameState.nextDirection = { x: 0, y: -1 };
                } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                    if (gameState.direction.y !== -1) gameState.nextDirection = { x: 0, y: 1 };
                } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    if (gameState.direction.x !== 1) gameState.nextDirection = { x: -1, y: 0 };
                } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    if (gameState.direction.x !== -1) gameState.nextDirection = { x: 1, y: 0 };
                }

                if (gameState.gameMode === 'twoPlayer') {
                    if (e.key === 'i' || e.key === 'I') {
                        if (gameState.direction2.y !== 1) gameState.nextDirection2 = { x: 0, y: -1 };
                    } else if (e.key === 'k' || e.key === 'K') {
                        if (gameState.direction2.y !== -1) gameState.nextDirection2 = { x: 0, y: 1 };
                    } else if (e.key === 'j' || e.key === 'J') {
                        if (gameState.direction2.x !== 1) gameState.nextDirection2 = { x: -1, y: 0 };
                    } else if (e.key === 'l' || e.key === 'L') {
                        if (gameState.direction2.x !== -1) gameState.nextDirection2 = { x: 1, y: 0 };
                    }
                }

                if (e.key === ' ' && gameState.playerLevel >= 11 && gameState.dashReady) {
                    doDash();
                }

                if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                    togglePause();
                }
            });
        }

        function setDirection(dir) {
            if (!gameState.gameRunning) return;
            switch(dir) {
                case 'up': if (gameState.direction.y !== 1) gameState.nextDirection = { x: 0, y: -1 }; break;
                case 'down': if (gameState.direction.y !== -1) gameState.nextDirection = { x: 0, y: 1 }; break;
                case 'left': if (gameState.direction.x !== 1) gameState.nextDirection = { x: -1, y: 0 }; break;
                case 'right': if (gameState.direction.x !== -1) gameState.nextDirection = { x: 1, y: 0 }; break;
            }
        }

        function doDash() {
            if (!gameState.dashReady || gameState.playerLevel < 11) return;

            gameState.dashReady = false;
            gameState.dashCooldown = 5000;

            const head = gameState.snake[0];
            for (let i = 0; i < 3; i++) {
                const newX = (head.x + gameState.direction.x * (i + 1) + GRID_SIZE) % GRID_SIZE;
                const newY = (head.y + gameState.direction.y * (i + 1) + GRID_SIZE) % GRID_SIZE;
                createParticles(newX * CELL_SIZE + CELL_SIZE/2, newY * CELL_SIZE + CELL_SIZE/2, '#ffff00', 5);
            }

            const newHead = {
                x: (head.x + gameState.direction.x * 3 + GRID_SIZE) % GRID_SIZE,
                y: (head.y + gameState.direction.y * 3 + GRID_SIZE) % GRID_SIZE
            };
            gameState.snake.unshift(newHead);
            gameState.snake.pop();
        }

        // ==================== GAME START ====================
        function startGame(mode, difficulty = 'medium') {
            gameState.gameMode = mode;
            gameState.aiDifficulty = difficulty;

            if (mode === 'twoPlayer' && !gameState.tutorialsShown.includes('twoPlayer') && !gameState.skipTutorials) {
                showTutorial('twoPlayer');
            } else if (mode === 'ai' && !gameState.tutorialsShown.includes('aiMode') && !gameState.skipTutorials) {
                showTutorial('aiMode');
            }

            resetGame();

            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            document.getElementById('aiModal').style.display = 'none';

            if (gameState.playerLevel >= 11) {
                document.getElementById('dashContainer').style.display = 'block';
                document.getElementById('dashBtn').style.display = 'block';
            }

            if (mode === 'timeAttack') {
                document.getElementById('timerItem').style.display = 'block';
                gameState.timeRemaining = 60;
            } else {
                document.getElementById('timerItem').style.display = 'none';
            }

            gameState.gameRunning = true;
            gameState.gamePaused = false;
            gameState.lastUpdateTime = performance.now();
            gameState.animationProgress = 0;

            gameLoop = setInterval(update, gameState.currentSpeed);
            renderLoop = requestAnimationFrame(render);

            if (mode === 'timeAttack') {
                setInterval(() => {
                    if (gameState.gameRunning && !gameState.gamePaused && gameState.timeRemaining > 0) {
                        gameState.timeRemaining--;
                        document.getElementById('timerDisplay').textContent = gameState.timeRemaining;
                        if (gameState.timeRemaining <= 0) {
                            endGame('Time\'s up!');
                        }
                    }
                }, 1000);
            }

            if (mode === 'survival') {
                setInterval(() => {
                    if (gameState.gameRunning && !gameState.gamePaused && gameState.arenaSize > 10) {
                        gameState.arenaSize--;
                        showToast('Arena shrinking!');
                    }
                }, 10000);
            }
        }

        function resetGame() {
            gameState.snake = [
                { x: 5, y: 15 },
                { x: 4, y: 15 },
                { x: 3, y: 15 }
            ];

            // Initialize smooth positions
            gameState.snakePositions = gameState.snake.map(s => ({
                x: s.x * CELL_SIZE + CELL_SIZE/2,
                y: s.y * CELL_SIZE + CELL_SIZE/2
            }));

            if (gameState.gameMode === 'twoPlayer') {
                gameState.snake2 = [
                    { x: 25, y: 15 },
                    { x: 26, y: 15 },
                    { x: 27, y: 15 }
                ];
                gameState.direction2 = { x: -1, y: 0 };
                gameState.score2 = 0;
            }

            if (gameState.gameMode === 'ai') {
                gameState.aiSnake = [
                    { x: 25, y: 15 },
                    { x: 26, y: 15 },
                    { x: 27, y: 15 }
                ];
                gameState.aiDirection = { x: -1, y: 0 };
                gameState.aiScore = 0;
            }

            gameState.direction = { x: 1, y: 0 };
            gameState.nextDirection = null;
            gameState.score = 0;
            gameState.combo = 1;
            gameState.lastFoodType = null;
            gameState.powerUps = [];
            gameState.obstacles = [];
            gameState.portals = [];
            gameState.particles = [];
            gameState.trailPoints = [];
            gameState.arenaSize = 30;

            gameState.speedBoost = false;
            gameState.shield = false;
            gameState.scoreMultiplier = false;
            gameState.ghostMode = false;
            gameState.magnetMode = false;
            gameState.dashReady = true;
            gameState.dashCooldown = 0;

            gameState.currentSpeed = gameState.baseSpeed;

            spawnFood();

            if (gameState.playerLevel >= 5) {
                spawnObstacles(3);
            }

            if (gameState.playerLevel >= 10) {
                spawnPortals();
            }

            if (gameState.customWalls.length > 0) {
                gameState.obstacles = [...gameState.customWalls];
            }

            updateDisplay();
        }

        // ==================== SPAWNING ====================
        function spawnFood() {
            let pos;
            do {
                pos = {
                    x: Math.floor(Math.random() * gameState.arenaSize),
                    y: Math.floor(Math.random() * gameState.arenaSize)
                };
            } while (isOccupied(pos.x, pos.y));

            let type = 'normal';
            const rand = Math.random();

            if (gameState.playerLevel >= 12 && rand < 0.10 && gameState.snake.length >= 4) {
                type = 'poison';
            } else if (gameState.playerLevel >= 4 && rand < 0.25) {
                type = 'golden';
            }

            gameState.food = {
                x: pos.x,
                y: pos.y,
                type: type,
                timer: type === 'golden' ? 5000 : null,
                pulse: 0
            };
        }

        function spawnPowerUp() {
            if (gameState.powerUps.length >= 2) return;
            if (Math.random() > 0.02) return;

            const availablePowerUps = [];
            if (gameState.playerLevel >= 2) availablePowerUps.push('speed');
            if (gameState.playerLevel >= 3) availablePowerUps.push('shield');
            if (gameState.playerLevel >= 6) availablePowerUps.push('multiplier');
            if (gameState.playerLevel >= 8) availablePowerUps.push('ghost');
            if (gameState.playerLevel >= 9) availablePowerUps.push('magnet');

            if (availablePowerUps.length === 0) return;

            let pos;
            do {
                pos = {
                    x: Math.floor(Math.random() * gameState.arenaSize),
                    y: Math.floor(Math.random() * gameState.arenaSize)
                };
            } while (isOccupied(pos.x, pos.y));

            const type = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
            gameState.powerUps.push({ x: pos.x, y: pos.y, type: type, pulse: 0 });
        }

        function spawnObstacles(count) {
            for (let i = 0; i < count; i++) {
                let pos;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (gameState.arenaSize - 4)) + 2,
                        y: Math.floor(Math.random() * (gameState.arenaSize - 4)) + 2
                    };
                } while (isOccupied(pos.x, pos.y));

                gameState.obstacles.push({ x: pos.x, y: pos.y, moving: gameState.playerLevel >= 14 && Math.random() < 0.3 });
            }
        }

        function spawnPortals() {
            for (let i = 0; i < 2; i++) {
                let pos1, pos2;
                do {
                    pos1 = {
                        x: Math.floor(Math.random() * (gameState.arenaSize - 4)) + 2,
                        y: Math.floor(Math.random() * (gameState.arenaSize - 4)) + 2
                    };
                } while (isOccupied(pos1.x, pos1.y));

                do {
                    pos2 = {
                        x: Math.floor(Math.random() * (gameState.arenaSize - 4)) + 2,
                        y: Math.floor(Math.random() * (gameState.arenaSize - 4)) + 2
                    };
                } while (isOccupied(pos2.x, pos2.y) || (pos2.x === pos1.x && pos2.y === pos1.y));

                gameState.portals.push(
                    { x: pos1.x, y: pos1.y, type: 'orange', pairId: i, rotation: 0 },
                    { x: pos2.x, y: pos2.y, type: 'blue', pairId: i, rotation: 0 }
                );
            }
        }

        function isOccupied(x, y) {
            if (gameState.snake.some(s => s.x === x && s.y === y)) return true;
            if (gameState.snake2.some(s => s.x === x && s.y === y)) return true;
            if (gameState.aiSnake.some(s => s.x === x && s.y === y)) return true;
            if (gameState.food && gameState.food.x === x && gameState.food.y === y) return true;
            if (gameState.obstacles.some(o => o.x === x && o.y === y)) return true;
            if (gameState.powerUps.some(p => p.x === x && p.y === y)) return true;
            if (gameState.portals.some(p => p.x === x && p.y === y)) return true;
            return false;
        }

        // ==================== GAME UPDATE ====================
        function update() {
            if (gameState.gamePaused) return;

            if (gameState.nextDirection) {
                gameState.direction = gameState.nextDirection;
                gameState.nextDirection = null;
            }
            if (gameState.nextDirection2) {
                gameState.direction2 = gameState.nextDirection2;
                gameState.nextDirection2 = null;
            }

            // Store previous positions for smooth interpolation
            gameState.snakePositions = gameState.snake.map(s => ({
                x: s.x * CELL_SIZE + CELL_SIZE/2,
                y: s.y * CELL_SIZE + CELL_SIZE/2
            }));

            updateSnake(gameState.snake, gameState.direction, 1);

            if (gameState.gameMode === 'twoPlayer') {
                updateSnake(gameState.snake2, gameState.direction2, 2);
            }

            if (gameState.gameMode === 'ai') {
                updateAI();
                updateSnake(gameState.aiSnake, gameState.aiDirection, 3);
            }

            if (gameState.playerLevel >= 14) {
                updateMovingObstacles();
            }

            spawnPowerUp();
            updatePowerUpTimers();

            if (!gameState.dashReady) {
                gameState.dashCooldown -= gameState.currentSpeed;
                if (gameState.dashCooldown <= 0) {
                    gameState.dashReady = true;
                }
                document.getElementById('dashBar').style.width = ((5000 - gameState.dashCooldown) / 5000 * 100) + '%';
            }

            if (gameState.food && gameState.food.type === 'golden') {
                gameState.food.timer -= gameState.currentSpeed;
                if (gameState.food.timer <= 0) {
                    spawnFood();
                }
            }

            if (gameState.magnetMode && gameState.food) {
                const head = gameState.snake[0];
                const dx = head.x - gameState.food.x;
                const dy = head.y - gameState.food.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= 5 && dist > 0) {
                    gameState.food.x += Math.sign(dx);
                    gameState.food.y += Math.sign(dy);
                }
            }

            if (gameState.gameMode === 'twoPlayer' || gameState.gameMode === 'ai') {
                if (gameState.score >= 200) {
                    endGame('Player 1 Wins!');
                } else if (gameState.score2 >= 200 || gameState.aiScore >= 200) {
                    endGame(gameState.gameMode === 'twoPlayer' ? 'Player 2 Wins!' : 'AI Wins!');
                }
            }

            gameState.animationProgress = 0;
            gameState.lastUpdateTime = performance.now();

            updateDisplay();
        }

        function updateSnake(snake, direction, player) {
            if (snake.length === 0) return;

            const head = snake[0];
            let newHead = {
                x: head.x + direction.x,
                y: head.y + direction.y
            };

            const portal = gameState.portals.find(p => p.x === newHead.x && p.y === newHead.y);
            if (portal) {
                const exitPortal = gameState.portals.find(p => p.pairId === portal.pairId && p.type !== portal.type);
                if (exitPortal) {
                    newHead = { x: exitPortal.x + direction.x, y: exitPortal.y + direction.y };
                    createParticles(exitPortal.x * CELL_SIZE + CELL_SIZE/2, exitPortal.y * CELL_SIZE + CELL_SIZE/2, '#00ccff', 15);
                }
            }

            const isOutOfBounds = newHead.x < 0 || newHead.x >= gameState.arenaSize ||
                                  newHead.y < 0 || newHead.y >= gameState.arenaSize;

            if (isOutOfBounds) {
                if (gameState.ghostMode && player === 1) {
                    newHead.x = (newHead.x + gameState.arenaSize) % gameState.arenaSize;
                    newHead.y = (newHead.y + gameState.arenaSize) % gameState.arenaSize;
                } else if (gameState.shield && player === 1) {
                    gameState.shield = false;
                    showToast('Shield used!');
                    return;
                } else {
                    handleDeath(player);
                    return;
                }
            }

            const hitObstacle = gameState.obstacles.some(o => o.x === newHead.x && o.y === newHead.y);
            if (hitObstacle) {
                if (gameState.ghostMode && player === 1) {
                } else if (gameState.shield && player === 1) {
                    gameState.shield = false;
                    showToast('Shield used!');
                    return;
                } else {
                    handleDeath(player);
                    return;
                }
            }

            const selfCollision = snake.slice(1).some(s => s.x === newHead.x && s.y === newHead.y);
            if (selfCollision) {
                if (gameState.ghostMode && player === 1) {
                } else if (gameState.shield && player === 1) {
                    gameState.shield = false;
                    showToast('Shield used!');
                    return;
                } else {
                    handleDeath(player);
                    return;
                }
            }

            if (gameState.gameMode === 'twoPlayer' || gameState.gameMode === 'ai') {
                const otherSnake = player === 1 ? (gameState.gameMode === 'twoPlayer' ? gameState.snake2 : gameState.aiSnake) : gameState.snake;
                if (otherSnake.some(s => s.x === newHead.x && s.y === newHead.y)) {
                    handleDeath(player);
                    return;
                }
            }

            snake.unshift(newHead);

            // Add trail point for player 1 snake
            if (player === 1) {
                const skin = SNAKE_SKINS[gameState.currentSkin];
                if (skin.trail) {
                    gameState.trailPoints.push({
                        x: newHead.x * CELL_SIZE + CELL_SIZE/2,
                        y: newHead.y * CELL_SIZE + CELL_SIZE/2,
                        life: 1,
                        color: skin.trailColor
                    });
                }
            }

            if (gameState.food && newHead.x === gameState.food.x && newHead.y === gameState.food.y) {
                let points = 10;
                let grow = true;

                if (gameState.food.type === 'golden') {
                    points = 30;
                } else if (gameState.food.type === 'poison') {
                    points = 50;
                    grow = false;
                    if (snake.length > 1) snake.pop();
                }

                if (gameState.playerLevel >= 7) {
                    if (gameState.lastFoodType === gameState.food.type) {
                        gameState.combo = Math.min(5, gameState.combo + 1);
                    } else {
                        gameState.combo = 1;
                    }
                    gameState.lastFoodType = gameState.food.type;
                }

                points *= gameState.combo;
                if (gameState.scoreMultiplier) points *= 2;

                if (player === 1) {
                    gameState.score += points;
                } else if (player === 2) {
                    gameState.score2 += points;
                } else if (player === 3) {
                    gameState.aiScore += points;
                }

                const color = gameState.food.type === 'golden' ? '#ffd700' : gameState.food.type === 'poison' ? '#9b59b6' : '#ff4444';
                createParticles(gameState.food.x * CELL_SIZE + CELL_SIZE/2, gameState.food.y * CELL_SIZE + CELL_SIZE/2, color, 20);

                spawnFood();

                if (!grow) return;
            } else {
                snake.pop();
            }

            const powerUpIndex = gameState.powerUps.findIndex(p => p.x === newHead.x && p.y === newHead.y);
            if (powerUpIndex !== -1 && player === 1) {
                const powerUp = gameState.powerUps[powerUpIndex];
                activatePowerUp(powerUp.type);
                gameState.powerUps.splice(powerUpIndex, 1);
                createParticles(newHead.x * CELL_SIZE + CELL_SIZE/2, newHead.y * CELL_SIZE + CELL_SIZE/2, '#00ccff', 20);
                gameState.combo = 1;
            }
        }

        function handleDeath(player) {
            if (player === 1) {
                // Death particles
                gameState.snake.forEach(s => {
                    createParticles(s.x * CELL_SIZE + CELL_SIZE/2, s.y * CELL_SIZE + CELL_SIZE/2, '#ff4444', 5);
                });

                if (gameState.gameMode === 'twoPlayer' || gameState.gameMode === 'ai') {
                    gameState.snake = [];
                    endGame(gameState.gameMode === 'twoPlayer' ? 'Player 2 Wins!' : 'AI Wins!');
                } else {
                    endGame('Game Over');
                }
            } else if (player === 2) {
                gameState.snake2 = [];
                endGame('Player 1 Wins!');
            } else if (player === 3) {
                gameState.aiSnake = [];
                endGame('Player 1 Wins!');
            }
        }

        function updateAI() {
            if (gameState.aiSnake.length === 0 || !gameState.food) return;

            const head = gameState.aiSnake[0];
            const target = gameState.food;

            let directions = [
                { x: 0, y: -1 },
                { x: 0, y: 1 },
                { x: -1, y: 0 },
                { x: 1, y: 0 }
            ];

            directions = directions.filter(d => !(d.x === -gameState.aiDirection.x && d.y === -gameState.aiDirection.y));

            directions.forEach(d => {
                const newPos = { x: head.x + d.x, y: head.y + d.y };
                d.score = 0;

                const distToFood = Math.abs(newPos.x - target.x) + Math.abs(newPos.y - target.y);
                d.score -= distToFood;

                if (newPos.x < 0 || newPos.x >= GRID_SIZE || newPos.y < 0 || newPos.y >= GRID_SIZE) {
                    d.score -= 1000;
                }

                if (gameState.aiSnake.some(s => s.x === newPos.x && s.y === newPos.y)) {
                    d.score -= 1000;
                }

                if (gameState.snake.some(s => s.x === newPos.x && s.y === newPos.y)) {
                    d.score -= 1000;
                }

                if (gameState.obstacles.some(o => o.x === newPos.x && o.y === newPos.y)) {
                    d.score -= 1000;
                }
            });

            const randomFactor = gameState.aiDifficulty === 'easy' ? 0.3 : gameState.aiDifficulty === 'medium' ? 0.1 : 0.02;
            if (Math.random() < randomFactor) {
                const validDirs = directions.filter(d => d.score > -500);
                if (validDirs.length > 0) {
                    gameState.aiDirection = validDirs[Math.floor(Math.random() * validDirs.length)];
                    return;
                }
            }

            directions.sort((a, b) => b.score - a.score);
            if (directions[0].score > -500) {
                gameState.aiDirection = { x: directions[0].x, y: directions[0].y };
            }
        }

        function updateMovingObstacles() {
            gameState.obstacles.forEach(obs => {
                if (!obs.moving) return;
                if (Math.random() < 0.05) {
                    const dirs = [{ x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }];
                    const dir = dirs[Math.floor(Math.random() * dirs.length)];
                    const newX = obs.x + dir.x;
                    const newY = obs.y + dir.y;
                    if (newX >= 2 && newX < GRID_SIZE - 2 && newY >= 2 && newY < GRID_SIZE - 2) {
                        if (!isOccupied(newX, newY)) {
                            obs.x = newX;
                            obs.y = newY;
                        }
                    }
                }
            });
        }

        function updatePowerUpTimers() {
            if (gameState.speedBoost) {
                gameState.speedBoostTimer -= gameState.baseSpeed;
                if (gameState.speedBoostTimer <= 0) {
                    gameState.speedBoost = false;
                    clearInterval(gameLoop);
                    gameState.currentSpeed = gameState.baseSpeed;
                    gameLoop = setInterval(update, gameState.currentSpeed);
                }
            }

            if (gameState.scoreMultiplier) {
                gameState.scoreMultiplierTimer -= gameState.currentSpeed;
                if (gameState.scoreMultiplierTimer <= 0) {
                    gameState.scoreMultiplier = false;
                }
            }

            if (gameState.ghostMode) {
                gameState.ghostModeTimer -= gameState.currentSpeed;
                if (gameState.ghostModeTimer <= 0) {
                    gameState.ghostMode = false;
                }
            }

            if (gameState.magnetMode) {
                gameState.magnetModeTimer -= gameState.currentSpeed;
                if (gameState.magnetModeTimer <= 0) {
                    gameState.magnetMode = false;
                }
            }

            updatePowerUpDisplay();
        }

        function activatePowerUp(type) {
            switch(type) {
                case 'speed':
                    gameState.speedBoost = true;
                    gameState.speedBoostTimer = 5000;
                    clearInterval(gameLoop);
                    gameState.currentSpeed = gameState.baseSpeed / 2;
                    gameLoop = setInterval(update, gameState.currentSpeed);
                    showToast('Speed Boost activated!');
                    break;
                case 'shield':
                    gameState.shield = true;
                    showToast('Shield activated!');
                    break;
                case 'multiplier':
                    gameState.scoreMultiplier = true;
                    gameState.scoreMultiplierTimer = 8000;
                    showToast('2x Score Multiplier!');
                    break;
                case 'ghost':
                    gameState.ghostMode = true;
                    gameState.ghostModeTimer = 4000;
                    showToast('Ghost Mode activated!');
                    break;
                case 'magnet':
                    gameState.magnetMode = true;
                    gameState.magnetModeTimer = 6000;
                    showToast('Magnet activated!');
                    break;
            }
        }

        // ==================== RENDERING ====================
        function render() {
            if (!gameState.gameRunning) return;

            const now = performance.now();
            const elapsed = now - gameState.lastUpdateTime;
            gameState.animationProgress = Math.min(1, elapsed / gameState.currentSpeed);
            gameState.pulsePhase += 0.1;

            draw();
            updateParticlesAndTrails();

            renderLoop = requestAnimationFrame(render);
        }

        function draw() {
            const theme = GAME_THEMES[gameState.currentTheme];

            // Clear and draw background
            ctx.fillStyle = theme.background;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw grid lines
            ctx.strokeStyle = theme.gridColor;
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, CANVAS_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(CANVAS_SIZE, i * CELL_SIZE);
                ctx.stroke();
            }

            // Update canvas border
            canvas.style.borderColor = theme.borderColor;

            // Draw arena boundary for survival mode
            if (gameState.gameMode === 'survival' && gameState.arenaSize < 30) {
                ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
                const offset = (30 - gameState.arenaSize) * CELL_SIZE / 2;
                ctx.fillRect(0, 0, CANVAS_SIZE, offset);
                ctx.fillRect(0, CANVAS_SIZE - offset, CANVAS_SIZE, offset);
                ctx.fillRect(0, 0, offset, CANVAS_SIZE);
                ctx.fillRect(CANVAS_SIZE - offset, 0, offset, CANVAS_SIZE);
            }

            // Draw obstacles
            gameState.obstacles.forEach(obs => {
                ctx.fillStyle = obs.moving ? '#ff6b6b' : '#8b4513';
                ctx.fillRect(obs.x * CELL_SIZE + 2, obs.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            });

            // Draw portals with rotation
            gameState.portals.forEach(portal => {
                portal.rotation += 0.05;
                const cx = portal.x * CELL_SIZE + CELL_SIZE/2;
                const cy = portal.y * CELL_SIZE + CELL_SIZE/2;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(portal.rotation);

                const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, CELL_SIZE/2);
                if (portal.type === 'orange') {
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#ff8800');
                    gradient.addColorStop(1, '#cc5500');
                } else {
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.3, '#00ccff');
                    gradient.addColorStop(1, '#0066aa');
                }

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, CELL_SIZE/2 - 2, 0, Math.PI * 2);
                ctx.fill();

                // Swirl effect
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, CELL_SIZE/3, 0, Math.PI);
                ctx.stroke();

                ctx.restore();
            });

            // Draw food with pulse
            if (gameState.food) {
                gameState.food.pulse += 0.1;
                const pulseScale = 1 + Math.sin(gameState.food.pulse) * 0.15;

                let foodColor = '#ff4444';
                let glowColor = 'rgba(255, 68, 68, 0.5)';
                if (gameState.food.type === 'golden') {
                    foodColor = '#ffd700';
                    glowColor = 'rgba(255, 215, 0, 0.5)';
                } else if (gameState.food.type === 'poison') {
                    foodColor = '#9b59b6';
                    glowColor = 'rgba(155, 89, 182, 0.5)';
                }

                const fx = gameState.food.x * CELL_SIZE + CELL_SIZE/2;
                const fy = gameState.food.y * CELL_SIZE + CELL_SIZE/2;

                // Glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = glowColor;

                ctx.fillStyle = foodColor;
                ctx.beginPath();
                ctx.arc(fx, fy, (CELL_SIZE/2 - 2) * pulseScale, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;

                // Sparkle for golden
                if (gameState.food.type === 'golden') {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = gameState.food.pulse + (i * Math.PI / 2);
                        const sx = fx + Math.cos(angle) * CELL_SIZE * 0.4;
                        const sy = fy + Math.sin(angle) * CELL_SIZE * 0.4;
                        ctx.beginPath();
                        ctx.moveTo(sx - 3, sy);
                        ctx.lineTo(sx + 3, sy);
                        ctx.moveTo(sx, sy - 3);
                        ctx.lineTo(sx, sy + 3);
                        ctx.stroke();
                    }
                }
            }

            // Draw power-ups with pulse
            gameState.powerUps.forEach(pu => {
                pu.pulse += 0.1;
                const pulseScale = 1 + Math.sin(pu.pulse) * 0.1;

                let color, icon;
                switch(pu.type) {
                    case 'speed': color = '#ffff00'; icon = '‚ö°'; break;
                    case 'shield': color = '#00ccff'; icon = 'üõ°Ô∏è'; break;
                    case 'multiplier': color = '#ff8800'; icon = '‚úñÔ∏è'; break;
                    case 'ghost': color = '#9b59b6'; icon = 'üëª'; break;
                    case 'magnet': color = '#ff6b6b'; icon = 'üß≤'; break;
                }

                const px = pu.x * CELL_SIZE + CELL_SIZE/2;
                const py = pu.y * CELL_SIZE + CELL_SIZE/2;

                ctx.shadowBlur = 10;
                ctx.shadowColor = color;

                ctx.fillStyle = color;
                const size = (CELL_SIZE - 4) * pulseScale;
                ctx.fillRect(px - size/2, py - size/2, size, size);

                ctx.shadowBlur = 0;

                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(icon, px, py);
            });

            // Draw snakes
            drawSnakeSmooth(gameState.snake, gameState.currentSkin, gameState.ghostMode, true);

            if (gameState.gameMode === 'twoPlayer') {
                drawSnakeSmooth(gameState.snake2, 'classic', false, false, '#ff00ff');
            }

            if (gameState.gameMode === 'ai') {
                drawSnakeSmooth(gameState.aiSnake, 'classic', false, false, '#ff6b6b');
            }
        }

        function drawSnakeSmooth(snake, skinId, transparent, isPlayer1, overrideColor = null) {
            if (snake.length === 0) return;

            const skin = SNAKE_SKINS[skinId] || SNAKE_SKINS.classic;
            const baseAlpha = transparent ? 0.5 : 1;

            // Calculate smooth positions
            const smoothSnake = snake.map((segment, index) => {
                const targetX = segment.x * CELL_SIZE + CELL_SIZE/2;
                const targetY = segment.y * CELL_SIZE + CELL_SIZE/2;

                if (isPlayer1 && gameState.snakePositions[index]) {
                    const prevX = gameState.snakePositions[index].x;
                    const prevY = gameState.snakePositions[index].y;
                    return {
                        x: prevX + (targetX - prevX) * gameState.animationProgress,
                        y: prevY + (targetY - prevY) * gameState.animationProgress
                    };
                }
                return { x: targetX, y: targetY };
            });

            // Draw smooth curved body
            if (smoothSnake.length > 1) {
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw body segments with gradient
                for (let i = smoothSnake.length - 1; i >= 1; i--) {
                    const progress = i / smoothSnake.length;
                    const alpha = baseAlpha * (1 - progress * 0.4);

                    let segmentColor;
                    if (overrideColor) {
                        segmentColor = overrideColor;
                    } else if (skin.pattern === 'rainbow') {
                        const colorIndex = (i + Math.floor(gameState.pulsePhase)) % skin.colors.length;
                        segmentColor = skin.colors[colorIndex];
                    } else {
                        const colorIndex = Math.floor(progress * (skin.colors.length - 1));
                        segmentColor = skin.colors[Math.min(colorIndex, skin.colors.length - 1)];
                    }

                    ctx.globalAlpha = alpha;

                    // Draw segment
                    const curr = smoothSnake[i];
                    const prev = smoothSnake[i - 1];

                    // Draw connection line
                    ctx.strokeStyle = segmentColor;
                    ctx.lineWidth = CELL_SIZE - 4;
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(curr.x, curr.y);
                    ctx.stroke();

                    // Draw segment circle
                    ctx.fillStyle = segmentColor;
                    ctx.beginPath();
                    ctx.arc(curr.x, curr.y, (CELL_SIZE - 4) / 2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.globalAlpha = baseAlpha;
            }

            // Draw head
            const head = smoothSnake[0];
            let headColor = overrideColor || skin.colors[0];

            // Pulse effect for certain skins
            if (skin.pattern === 'pulse' && !overrideColor) {
                const pulse = Math.sin(gameState.pulsePhase * 2) * 0.3 + 0.7;
                ctx.globalAlpha = baseAlpha * pulse;
            }

            // Glow effect
            if (!overrideColor) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = skin.glow;
            }

            ctx.fillStyle = headColor;
            ctx.beginPath();
            ctx.arc(head.x, head.y, CELL_SIZE/2 - 1, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

            // Draw eyes
            ctx.fillStyle = '#000';
            const eyeOffset = 4;
            const eyeSize = 3;
            const direction = gameState.direction;

            let eye1X = head.x - eyeOffset;
            let eye2X = head.x + eyeOffset;
            let eye1Y = head.y - eyeOffset;
            let eye2Y = head.y - eyeOffset;

            if (direction.x === 1) { eye1X = eye2X = head.x + 3; eye1Y = head.y - 4; eye2Y = head.y + 4; }
            else if (direction.x === -1) { eye1X = eye2X = head.x - 3; eye1Y = head.y - 4; eye2Y = head.y + 4; }
            else if (direction.y === 1) { eye1Y = eye2Y = head.y + 3; eye1X = head.x - 4; eye2X = head.x + 4; }
            else if (direction.y === -1) { eye1Y = eye2Y = head.y - 3; eye1X = head.x - 4; eye2X = head.x + 4; }

            ctx.beginPath();
            ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
            ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
            ctx.fill();

            // Shield glow for player 1
            if (gameState.shield && isPlayer1) {
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ccff';
                ctx.beginPath();
                ctx.arc(head.x, head.y, CELL_SIZE/2 + 4 + Math.sin(gameState.pulsePhase) * 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            ctx.globalAlpha = 1;
        }

        // ==================== PARTICLES & TRAILS ====================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10 - 3,
                    color: color,
                    life: 1,
                    size: Math.random() * 5 + 3
                });
            }
        }

        function updateParticlesAndTrails() {
            // Clear trail canvas with fade
            trailCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            trailCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw and update trails
            gameState.trailPoints = gameState.trailPoints.filter(t => {
                t.life -= 0.02;
                if (t.life > 0) {
                    trailCtx.globalAlpha = t.life * 0.5;
                    trailCtx.fillStyle = t.color;
                    trailCtx.beginPath();
                    trailCtx.arc(t.x, t.y, 8 * t.life, 0, Math.PI * 2);
                    trailCtx.fill();
                    return true;
                }
                return false;
            });
            trailCtx.globalAlpha = 1;

            // Clear particle canvas
            particleCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw and update particles
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3;
                p.life -= 0.025;

                if (p.life > 0) {
                    particleCtx.globalAlpha = p.life;
                    particleCtx.fillStyle = p.color;
                    particleCtx.shadowBlur = 10;
                    particleCtx.shadowColor = p.color;
                    particleCtx.beginPath();
                    particleCtx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                    particleCtx.fill();
                    return true;
                }
                return false;
            });
            particleCtx.shadowBlur = 0;
            particleCtx.globalAlpha = 1;
        }

        // ==================== UI ====================
        function updateDisplay() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('highScoreDisplay').textContent = Math.max(gameState.highScore, gameState.score);
            document.getElementById('lengthDisplay').textContent = gameState.snake.length;
            document.getElementById('comboDisplay').textContent = gameState.combo + 'x';

            if (gameState.combo >= 3) {
                document.getElementById('comboDisplay').style.color = '#ff8800';
            } else {
                document.getElementById('comboDisplay').style.color = '#00ff88';
            }
        }

        function updatePowerUpDisplay() {
            const container = document.getElementById('powerUpsDisplay');
            container.innerHTML = '';

            if (gameState.speedBoost) {
                container.innerHTML += `<div class="power-up-active"><span class="power-up-icon">‚ö°</span><span>Speed ${(gameState.speedBoostTimer/1000).toFixed(1)}s</span></div>`;
            }
            if (gameState.shield) {
                container.innerHTML += `<div class="power-up-active"><span class="power-up-icon">üõ°Ô∏è</span><span>Shield Ready</span></div>`;
            }
            if (gameState.scoreMultiplier) {
                container.innerHTML += `<div class="power-up-active"><span class="power-up-icon">‚úñÔ∏è</span><span>2x Points ${(gameState.scoreMultiplierTimer/1000).toFixed(1)}s</span></div>`;
            }
            if (gameState.ghostMode) {
                container.innerHTML += `<div class="power-up-active"><span class="power-up-icon">üëª</span><span>Ghost ${(gameState.ghostModeTimer/1000).toFixed(1)}s</span></div>`;
            }
            if (gameState.magnetMode) {
                container.innerHTML += `<div class="power-up-active"><span class="power-up-icon">üß≤</span><span>Magnet ${(gameState.magnetModeTimer/1000).toFixed(1)}s</span></div>`;
            }
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // ==================== GAME END ====================
        function endGame(message) {
            gameState.gameRunning = false;
            clearInterval(gameLoop);
            cancelAnimationFrame(renderLoop);

            const xpEarned = Math.floor(gameState.score / 5);
            const coinsEarned = Math.floor(gameState.score / 10);

            gameState.xp += xpEarned;
            gameState.coins += coinsEarned;
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
            }

            let leveledUp = false;
            while (gameState.playerLevel < 20 && gameState.xp >= LEVEL_XP[gameState.playerLevel]) {
                gameState.playerLevel++;
                leveledUp = true;
            }

            saveProgress();

            document.getElementById('gameOverTitle').textContent = message;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalLength').textContent = gameState.snake.length || 0;
            document.getElementById('xpEarned').textContent = '+' + xpEarned;
            document.getElementById('coinsEarned').textContent = '+' + coinsEarned;
            document.getElementById('gameOverModal').style.display = 'flex';

            if (leveledUp) {
                setTimeout(() => {
                    document.getElementById('gameOverModal').style.display = 'none';
                    showLevelUp();
                }, 2000);
            }
        }

        function showLevelUp() {
            document.getElementById('newLevelDisplay').textContent = gameState.playerLevel;
            const unlock = LEVEL_UNLOCKS[gameState.playerLevel];
            if (unlock) {
                document.getElementById('levelUpUnlock').innerHTML = `<span style="font-size: 2em;">${unlock.icon}</span><br><strong>${unlock.name}</strong><br>${unlock.desc}`;
            } else {
                document.getElementById('levelUpUnlock').innerHTML = 'Keep playing to unlock more features!';
            }
            document.getElementById('levelUpModal').style.display = 'flex';
        }

        function closeGameOver() {
            document.getElementById('gameOverModal').style.display = 'none';
            quitGame();
        }

        function closeLevelUp() {
            document.getElementById('levelUpModal').style.display = 'none';
            quitGame();
        }

        function togglePause() {
            if (!gameState.gameRunning) return;
            gameState.gamePaused = !gameState.gamePaused;
            document.getElementById('pauseOverlay').style.display = gameState.gamePaused ? 'flex' : 'none';
        }

        function quitGame() {
            gameState.gameRunning = false;
            clearInterval(gameLoop);
            cancelAnimationFrame(renderLoop);
            document.getElementById('gameScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
            updateMenuDisplay();
            updateSkinPreview();
        }

        // ==================== TUTORIALS ====================
        function showTutorial(key) {
            const tutorial = TUTORIALS[key];
            if (!tutorial) return;

            document.getElementById('tutorialIcon').textContent = tutorial.icon;
            document.getElementById('tutorialTitle').textContent = tutorial.title;
            document.getElementById('tutorialText').textContent = tutorial.text;
            document.getElementById('tutorialModal').style.display = 'flex';

            gameState.tutorialsShown.push(key);
            saveProgress();
        }

        function closeTutorial() {
            document.getElementById('tutorialModal').style.display = 'none';
        }

        function toggleSkipTutorials() {
            gameState.skipTutorials = document.getElementById('skipTutorials').checked;
            saveProgress();
        }

        // ==================== AI/EDITOR ====================
        function showAISelection() {
            document.getElementById('aiModal').style.display = 'flex';
        }

        function closeAIModal() {
            document.getElementById('aiModal').style.display = 'none';
        }

        function setupEditorControls() {
            let isDrawing = false;

            editorCanvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                handleEditorDraw(e);
            });

            editorCanvas.addEventListener('mousemove', (e) => {
                if (isDrawing) handleEditorDraw(e);
            });

            editorCanvas.addEventListener('mouseup', () => isDrawing = false);
            editorCanvas.addEventListener('mouseleave', () => isDrawing = false);
            editorCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

            function handleEditorDraw(e) {
                const rect = editorCanvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) / CELL_SIZE);

                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return;

                if (e.buttons === 1 && gameState.editorTool === 'wall') {
                    if (!gameState.editorWalls.some(w => w.x === x && w.y === y)) {
                        gameState.editorWalls.push({ x, y });
                    }
                } else if (e.buttons === 2 || (e.buttons === 1 && gameState.editorTool === 'erase')) {
                    gameState.editorWalls = gameState.editorWalls.filter(w => !(w.x === x && w.y === y));
                }

                renderEditor();
            }
        }

        function setEditorTool(tool) {
            gameState.editorTool = tool;
            document.getElementById('wallTool').classList.toggle('active', tool === 'wall');
            document.getElementById('eraseTool').classList.toggle('active', tool === 'erase');
        }

        function renderEditor() {
            const theme = GAME_THEMES[gameState.currentTheme];

            editorCtx.fillStyle = theme.background;
            editorCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            editorCtx.strokeStyle = theme.gridColor;
            for (let i = 0; i <= GRID_SIZE; i++) {
                editorCtx.beginPath();
                editorCtx.moveTo(i * CELL_SIZE, 0);
                editorCtx.lineTo(i * CELL_SIZE, CANVAS_SIZE);
                editorCtx.stroke();
                editorCtx.beginPath();
                editorCtx.moveTo(0, i * CELL_SIZE);
                editorCtx.lineTo(CANVAS_SIZE, i * CELL_SIZE);
                editorCtx.stroke();
            }

            editorCtx.fillStyle = '#8b4513';
            gameState.editorWalls.forEach(w => {
                editorCtx.fillRect(w.x * CELL_SIZE + 2, w.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            });
        }

        function openEditor() {
            if (!gameState.tutorialsShown.includes('editor') && !gameState.skipTutorials) {
                showTutorial('editor');
            }

            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('editorScreen').style.display = 'block';
            gameState.editorWalls = [];
            renderEditor();
        }

        function closeEditor() {
            document.getElementById('editorScreen').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
        }

        function clearEditor() {
            gameState.editorWalls = [];
            renderEditor();
        }

        function testLevel() {
            gameState.customWalls = [...gameState.editorWalls];
            document.getElementById('editorScreen').style.display = 'none';
            startGame('classic');
        }

        function saveLevel() {
            const code = btoa(JSON.stringify(gameState.editorWalls));
            document.getElementById('levelCodeInput').value = code;
            navigator.clipboard.writeText(code).then(() => {
                showToast('Level code copied to clipboard!');
            });
        }

        function loadLevel() {
            const code = document.getElementById('levelCodeInput').value.trim();
            if (!code) {
                showToast('Please enter a level code');
                return;
            }
            try {
                gameState.editorWalls = JSON.parse(atob(code));
                renderEditor();
                showToast('Level loaded!');
            } catch (e) {
                showToast('Invalid level code');
            }
        }

        // Initialize
        window.onload = init;
    </script>
</body>
</html>
