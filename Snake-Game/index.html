<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Ultimate</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }

        #mainMenu { text-align: center; padding: 40px 20px; }
        .game-title {
            font-size: 3.5em;
            font-weight: bold;
            background: linear-gradient(90deg, #00ff88, #00ccff, #ff8800, #00ff88);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            margin-bottom: 10px;
        }
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        .player-stats { display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap; }
        .stat-box {
            background: rgba(0,0,0,0.3);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #00ff88;
        }
        .stat-label { font-size: 0.9em; color: #aaa; }
        .stat-value { font-size: 1.5em; font-weight: bold; color: #00ff88; }
        .xp-bar-container {
            width: 100%; max-width: 400px; margin: 0 auto 20px;
            background: rgba(0,0,0,0.5); border-radius: 10px; padding: 5px;
            border: 2px solid #00ccff;
        }
        .xp-bar { height: 20px; background: linear-gradient(90deg, #00ff88, #00ccff); border-radius: 5px; transition: width 0.5s; }
        .xp-text { font-size: 0.9em; color: #ccc; margin-top: 5px; }

        .menu-buttons { display: flex; flex-direction: column; gap: 12px; align-items: center; margin-top: 20px; }
        .menu-btn {
            padding: 15px 40px; font-size: 1.1em; border: none; border-radius: 10px;
            cursor: pointer; transition: all 0.3s; width: 260px; font-weight: bold;
        }
        .menu-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(0,255,136,0.5); }
        .menu-btn.primary { background: linear-gradient(135deg, #00ff88, #00cc6a); color: #000; }
        .menu-btn.secondary { background: linear-gradient(135deg, #00ccff, #0099cc); color: #000; }
        .menu-btn.tertiary { background: linear-gradient(135deg, #ff8800, #cc6600); color: #000; }
        .menu-btn.quaternary { background: linear-gradient(135deg, #9b59b6, #7d3c98); color: #fff; }
        .menu-btn:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; }

        .skin-display {
            margin: 20px auto; padding: 15px; max-width: 300px;
            background: rgba(0,0,0,0.3); border-radius: 10px; border: 2px solid #e91e63;
        }
        .skin-preview { height: 25px; border-radius: 12px; margin: 10px 0; }
        .customize-btn {
            padding: 10px 25px; background: linear-gradient(135deg, #e91e63, #9c27b0);
            border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold;
        }

        #gameScreen { display: none; }
        .game-layout { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; }
        .canvas-wrap { position: relative; }
        #gameCanvas { display: block; border: 3px solid #00ff88; border-radius: 5px; box-shadow: 0 0 20px rgba(0,255,136,0.3); }

        .game-info {
            background: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px;
            border: 2px solid #00ccff; min-width: 180px;
        }
        .info-item { margin-bottom: 12px; }
        .info-label { font-size: 0.85em; color: #888; }
        .info-value { font-size: 1.6em; font-weight: bold; color: #00ff88; }
        .game-controls { display: flex; gap: 10px; margin-top: 15px; }
        .ctrl-btn { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .ctrl-btn.pause { background: #ff8800; color: #000; }
        .ctrl-btn.quit { background: #ff4444; color: #fff; }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 1000; justify-content: center; align-items: center;
        }
        .modal-box {
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            padding: 30px; border-radius: 15px; border: 3px solid #00ff88;
            max-width: 500px; text-align: center; max-height: 80vh; overflow-y: auto;
        }
        .modal-title { font-size: 1.8em; color: #00ff88; margin-bottom: 15px; }
        .modal-btn {
            padding: 12px 35px; font-size: 1em; border: none; border-radius: 8px;
            cursor: pointer; background: #00ff88; color: #000; font-weight: bold; margin-top: 15px;
        }

        .skin-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 15px 0; }
        .skin-opt {
            padding: 12px; border-radius: 8px; border: 2px solid transparent;
            cursor: pointer; background: rgba(0,0,0,0.3); transition: all 0.3s;
        }
        .skin-opt:hover { border-color: #00ccff; }
        .skin-opt.selected { border-color: #00ff88; box-shadow: 0 0 10px rgba(0,255,136,0.5); }
        .skin-opt.locked { opacity: 0.4; cursor: not-allowed; }
        .skin-bar { height: 15px; border-radius: 8px; margin: 8px auto; width: 70px; }
        .skin-name { font-size: 0.85em; font-weight: bold; }
        .skin-lvl { font-size: 0.7em; color: #ff8800; }

        .toast {
            position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.9);
            padding: 12px 20px; border-radius: 8px; border: 2px solid #00ff88;
            z-index: 2000; animation: slideIn 0.3s;
        }
        @keyframes slideIn { from { transform: translateX(100%); } to { transform: translateX(0); } }

        .game-over-box { border-color: #ff4444 !important; }
        .game-over-title { color: #ff4444; font-size: 2em; margin-bottom: 15px; }
        .stat-row { display: flex; justify-content: space-between; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 5px; margin: 5px 0; }

        .mobile-controls { display: none; justify-content: center; margin-top: 15px; }
        .dpad { display: grid; grid-template-columns: repeat(3, 50px); gap: 5px; }
        .dpad-btn { width: 50px; height: 50px; font-size: 1.3em; border: none; border-radius: 8px; background: rgba(0,255,136,0.3); color: white; cursor: pointer; }
        .dpad-btn:nth-child(1) { grid-column: 2; }
        .dpad-btn:nth-child(2) { grid-column: 1; grid-row: 2; }
        .dpad-btn:nth-child(3) { grid-column: 3; grid-row: 2; }
        .dpad-btn:nth-child(4) { grid-column: 2; grid-row: 3; }

        @media (max-width: 700px) {
            .game-title { font-size: 2.2em; }
            #gameCanvas { width: 300px !important; height: 300px !important; }
            .mobile-controls { display: flex; }
            .skin-grid { grid-template-columns: repeat(2, 1fr); }
        }
    </style>
</head>
<body>
    <div id="mainMenu" class="container">
        <h1 class="game-title">SNAKE ULTIMATE</h1>
        <p style="color:#aaa">Progressive Snake with Unlockable Skins!</p>

        <div class="player-stats">
            <div class="stat-box"><div class="stat-label">LEVEL</div><div class="stat-value" id="menuLevel">1</div></div>
            <div class="stat-box"><div class="stat-label">HIGH SCORE</div><div class="stat-value" id="menuHigh">0</div></div>
            <div class="stat-box"><div class="stat-label">COINS</div><div class="stat-value" id="menuCoins">0</div></div>
        </div>

        <div class="xp-bar-container">
            <div class="xp-bar" id="xpBar" style="width:0%"></div>
        </div>
        <div class="xp-text" id="xpText">0 / 100 XP</div>

        <div class="skin-display">
            <div class="stat-label">CURRENT SKIN</div>
            <div class="skin-preview" id="skinPreview"></div>
            <button class="customize-btn" onclick="openCustomize()">Customize</button>
        </div>

        <div class="menu-buttons">
            <button class="menu-btn primary" onclick="startGame('classic')">Classic Mode</button>
            <button class="menu-btn secondary" onclick="startGame('twoPlayer')">Two Player</button>
            <button class="menu-btn tertiary" onclick="startGame('ai')">VS AI</button>
            <button class="menu-btn quaternary" onclick="openEditor()">Level Editor</button>
        </div>
    </div>

    <div id="gameScreen" class="container">
        <div class="game-layout">
            <div class="canvas-wrap">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
            </div>
            <div class="game-info">
                <div class="info-item"><div class="info-label">SCORE</div><div class="info-value" id="score">0</div></div>
                <div class="info-item"><div class="info-label">LENGTH</div><div class="info-value" id="length">3</div></div>
                <div class="info-item"><div class="info-label">COMBO</div><div class="info-value" id="combo">1x</div></div>
                <div id="powerDisplay"></div>
                <div class="game-controls">
                    <button class="ctrl-btn pause" onclick="togglePause()">Pause</button>
                    <button class="ctrl-btn quit" onclick="quitGame()">Quit</button>
                </div>
            </div>
        </div>
        <div class="mobile-controls">
            <div class="dpad">
                <button class="dpad-btn" onclick="setDir(0,-1)">‚Üë</button>
                <button class="dpad-btn" onclick="setDir(-1,0)">‚Üê</button>
                <button class="dpad-btn" onclick="setDir(1,0)">‚Üí</button>
                <button class="dpad-btn" onclick="setDir(0,1)">‚Üì</button>
            </div>
        </div>
    </div>

    <div id="editorScreen" class="container" style="display:none">
        <h2 style="text-align:center;margin-bottom:15px">Level Editor</h2>
        <div style="text-align:center;margin-bottom:15px">
            <button class="ctrl-btn" style="background:#00ff88;color:#000" onclick="editorTool='wall'">Wall</button>
            <button class="ctrl-btn" style="background:#ff4444" onclick="editorTool='erase'">Erase</button>
            <button class="ctrl-btn" style="background:#ff8800;color:#000" onclick="editorWalls=[];drawEditor()">Clear</button>
            <button class="ctrl-btn" style="background:#00ccff;color:#000" onclick="testLevel()">Test</button>
            <button class="ctrl-btn" style="background:#666" onclick="closeEditor()">Back</button>
        </div>
        <div style="text-align:center"><canvas id="editorCanvas" width="600" height="600" style="border:3px solid #00ff88;cursor:crosshair"></canvas></div>
    </div>

    <div class="modal" id="customModal">
        <div class="modal-box">
            <h2 class="modal-title">Customize Snake</h2>
            <h3 style="color:#00ccff;margin:15px 0 10px">Snake Skins</h3>
            <div class="skin-grid" id="skinGrid"></div>
            <h3 style="color:#00ccff;margin:15px 0 10px">Themes</h3>
            <div class="skin-grid" id="themeGrid"></div>
            <button class="modal-btn" onclick="closeCustomize()">Done</button>
        </div>
    </div>

    <div class="modal" id="gameOverModal">
        <div class="modal-box game-over-box">
            <h2 class="game-over-title" id="gameOverTitle">GAME OVER</h2>
            <div id="gameOverStats"></div>
            <button class="modal-btn" onclick="closeGameOver()">Continue</button>
        </div>
    </div>

    <div class="modal" id="levelUpModal">
        <div class="modal-box" style="border-color:#ff8800">
            <h2 style="color:#ff8800;font-size:2em">LEVEL UP!</h2>
            <p style="font-size:3em;margin:15px 0" id="newLevel">2</p>
            <div id="unlockInfo" style="background:rgba(0,255,136,0.2);padding:12px;border-radius:8px;border:2px solid #00ff88"></div>
            <button class="modal-btn" onclick="closeLevelUp()">Awesome!</button>
        </div>
    </div>

    <script>
    const CELL = 20, GRID = 30, SIZE = 600;

    const SKINS = {
        classic: { name: 'Classic', lvl: 1, colors: ['#00ff88','#00dd77','#00bb66'], glow: '#00ff88', trail: false },
        neon: { name: 'Neon', lvl: 3, colors: ['#00ffff','#00ddff','#00bbff'], glow: '#00ffff', trail: true, trailCol: 'rgba(0,255,255,0.4)' },
        fire: { name: 'Inferno', lvl: 5, colors: ['#ff4400','#ff6600','#ff8800'], glow: '#ff4400', trail: true, trailCol: 'rgba(255,68,0,0.4)' },
        rainbow: { name: 'Rainbow', lvl: 7, colors: ['#ff0000','#ff7700','#ffff00','#00ff00','#0000ff','#8b00ff'], glow: '#fff', trail: true, trailCol: 'rgba(255,255,255,0.3)' },
        galaxy: { name: 'Galaxy', lvl: 10, colors: ['#9b59b6','#8e44ad','#6c3483'], glow: '#9b59b6', trail: true, trailCol: 'rgba(155,89,182,0.4)' },
        frost: { name: 'Frost', lvl: 12, colors: ['#a8e6cf','#88d8b0','#56ab91'], glow: '#a8e6cf', trail: true, trailCol: 'rgba(168,230,207,0.4)' },
        gold: { name: 'Golden', lvl: 15, colors: ['#ffd700','#ffcc00','#ffaa00'], glow: '#ffd700', trail: true, trailCol: 'rgba(255,215,0,0.4)' },
        void: { name: 'Void', lvl: 18, colors: ['#1a1a2e','#16213e','#e94560'], glow: '#e94560', trail: true, trailCol: 'rgba(233,69,96,0.5)' },
        plasma: { name: 'Plasma', lvl: 20, colors: ['#ff00ff','#ff00aa','#aa00ff'], glow: '#ff00ff', trail: true, trailCol: 'rgba(255,0,255,0.4)' }
    };

    const THEMES = {
        classic: { name: 'Classic', lvl: 1, bg: '#000', grid: '#111', border: '#00ff88' },
        midnight: { name: 'Midnight', lvl: 4, bg: '#0d1b2a', grid: '#1b263b', border: '#00ccff' },
        sunset: { name: 'Sunset', lvl: 6, bg: '#2d132c', grid: '#3d1a3d', border: '#ff8800' },
        forest: { name: 'Forest', lvl: 8, bg: '#1a2f1a', grid: '#2a3f2a', border: '#00ff44' },
        ocean: { name: 'Ocean', lvl: 11, bg: '#0a1628', grid: '#142238', border: '#00ddff' },
        lava: { name: 'Lava', lvl: 14, bg: '#1a0a0a', grid: '#2a1515', border: '#ff4400' },
        cosmic: { name: 'Cosmic', lvl: 17, bg: '#0a0a1a', grid: '#151530', border: '#9b59b6' }
    };

    const LEVEL_XP = [0,100,250,450,700,1000,1400,1900,2500,3200,4000,4900,5900,7000,8500,10200,12100,14200,16500,19000];

    const UNLOCKS = {
        2: { icon: '‚ö°', name: 'Speed Boost', desc: 'Yellow lightning = faster!' },
        3: { icon: 'üé®', name: 'Neon Skin', desc: 'Glowing cyan snake!' },
        4: { icon: 'üåô', name: 'Midnight Theme', desc: 'Dark blue aesthetic' },
        5: { icon: 'üî•', name: 'Inferno Skin', desc: 'Fire snake with trails!' },
        6: { icon: 'üåÖ', name: 'Sunset Theme', desc: 'Warm purple hues' },
        7: { icon: 'üåà', name: 'Rainbow Skin', desc: 'Color-shifting snake!' },
        8: { icon: 'üå≤', name: 'Forest Theme', desc: 'Deep green forest' },
        10: { icon: '‚ú®', name: 'Galaxy Skin', desc: 'Cosmic purple!' },
        11: { icon: 'üåä', name: 'Ocean Theme', desc: 'Deep sea blues' },
        12: { icon: '‚ùÑÔ∏è', name: 'Frost Skin', desc: 'Icy shimmer!' },
        14: { icon: 'üåã', name: 'Lava Theme', desc: 'Hot reds and oranges' },
        15: { icon: 'üëë', name: 'Golden Skin', desc: 'Majestic gold!' },
        17: { icon: 'ü™ê', name: 'Cosmic Theme', desc: 'Space purple' },
        18: { icon: 'üï≥Ô∏è', name: 'Void Skin', desc: 'Dark matter!' },
        20: { icon: '‚ö°', name: 'Plasma Skin', desc: 'Ultimate energy!' }
    };

    let G = {
        level: 1, xp: 0, coins: 0, highScore: 0,
        skin: 'classic', theme: 'classic',
        snake: [], dir: {x:1,y:0}, nextDir: null,
        snake2: [], dir2: {x:-1,y:0}, aiSnake: [], aiDir: {x:-1,y:0},
        food: null, powerUps: [], obstacles: [], particles: [], trails: [],
        score: 0, score2: 0, aiScore: 0, combo: 1, lastFood: null,
        running: false, paused: false, mode: 'classic',
        speed: false, speedTime: 0, shield: false, ghost: false, ghostTime: 0,
        baseSpeed: 120, tick: 0
    };

    let canvas, ctx, editorCanvas, editorCtx;
    let gameInterval, animFrame;
    let editorWalls = [], editorTool = 'wall', customWalls = [];

    function init() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        editorCanvas = document.getElementById('editorCanvas');
        editorCtx = editorCanvas.getContext('2d');
        load();
        updateMenu();
        setupKeys();
        setupEditor();
    }

    function load() {
        const s = localStorage.getItem('snakeUltimate2');
        if (s) {
            const d = JSON.parse(s);
            G.level = d.level || 1;
            G.xp = d.xp || 0;
            G.coins = d.coins || 0;
            G.highScore = d.highScore || 0;
            G.skin = d.skin || 'classic';
            G.theme = d.theme || 'classic';
        }
    }

    function save() {
        localStorage.setItem('snakeUltimate2', JSON.stringify({
            level: G.level, xp: G.xp, coins: G.coins, highScore: G.highScore,
            skin: G.skin, theme: G.theme
        }));
    }

    function updateMenu() {
        document.getElementById('menuLevel').textContent = G.level;
        document.getElementById('menuHigh').textContent = G.highScore;
        document.getElementById('menuCoins').textContent = G.coins;

        const curr = LEVEL_XP[G.level - 1] || 0;
        const next = LEVEL_XP[G.level] || LEVEL_XP[LEVEL_XP.length - 1];
        const pct = Math.min(100, Math.max(0, ((G.xp - curr) / (next - curr)) * 100));
        document.getElementById('xpBar').style.width = pct + '%';
        document.getElementById('xpText').textContent = `${G.xp} / ${next} XP to Level ${G.level + 1}`;

        updateSkinPreview();
    }

    function updateSkinPreview() {
        const skin = SKINS[G.skin];
        const el = document.getElementById('skinPreview');
        el.style.background = `linear-gradient(90deg, ${skin.colors.join(',')})`;
        el.style.boxShadow = `0 0 12px ${skin.glow}`;
    }

    function setupKeys() {
        document.addEventListener('keydown', e => {
            if (!G.running) return;
            const k = e.key;
            if ((k === 'ArrowUp' || k === 'w') && G.dir.y !== 1) G.nextDir = {x:0,y:-1};
            else if ((k === 'ArrowDown' || k === 's') && G.dir.y !== -1) G.nextDir = {x:0,y:1};
            else if ((k === 'ArrowLeft' || k === 'a') && G.dir.x !== 1) G.nextDir = {x:-1,y:0};
            else if ((k === 'ArrowRight' || k === 'd') && G.dir.x !== -1) G.nextDir = {x:1,y:0};
            else if (k === 'p' || k === 'Escape') togglePause();

            if (G.mode === 'twoPlayer') {
                if (k === 'i' && G.dir2.y !== 1) G.dir2 = {x:0,y:-1};
                else if (k === 'k' && G.dir2.y !== -1) G.dir2 = {x:0,y:1};
                else if (k === 'j' && G.dir2.x !== 1) G.dir2 = {x:-1,y:0};
                else if (k === 'l' && G.dir2.x !== -1) G.dir2 = {x:1,y:0};
            }
        });
    }

    function setDir(x, y) {
        if (!G.running) return;
        if (x === 0 && y === -1 && G.dir.y !== 1) G.nextDir = {x,y};
        else if (x === 0 && y === 1 && G.dir.y !== -1) G.nextDir = {x,y};
        else if (x === -1 && y === 0 && G.dir.x !== 1) G.nextDir = {x,y};
        else if (x === 1 && y === 0 && G.dir.x !== -1) G.nextDir = {x,y};
    }

    function startGame(mode) {
        G.mode = mode;
        resetGame();
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('gameScreen').style.display = 'block';
        G.running = true;
        G.paused = false;
        G.tick = 0;
        gameInterval = setInterval(update, G.baseSpeed);
        animFrame = requestAnimationFrame(render);
    }

    function resetGame() {
        G.snake = [{x:5,y:15},{x:4,y:15},{x:3,y:15}];
        G.dir = {x:1,y:0};
        G.nextDir = null;
        G.score = 0;
        G.combo = 1;
        G.lastFood = null;
        G.particles = [];
        G.trails = [];
        G.powerUps = [];
        G.obstacles = [];
        G.speed = false;
        G.shield = false;
        G.ghost = false;

        if (G.mode === 'twoPlayer') {
            G.snake2 = [{x:24,y:15},{x:25,y:15},{x:26,y:15}];
            G.dir2 = {x:-1,y:0};
            G.score2 = 0;
        } else G.snake2 = [];

        if (G.mode === 'ai') {
            G.aiSnake = [{x:24,y:15},{x:25,y:15},{x:26,y:15}];
            G.aiDir = {x:-1,y:0};
            G.aiScore = 0;
        } else G.aiSnake = [];

        if (customWalls.length > 0) {
            G.obstacles = customWalls.map(w => ({...w}));
        } else if (G.level >= 5) {
            spawnObstacles(3);
        }

        spawnFood();
        updateUI();
    }

    function spawnFood() {
        let pos;
        let tries = 0;
        do {
            pos = { x: Math.floor(Math.random() * GRID), y: Math.floor(Math.random() * GRID) };
            tries++;
        } while (isBlocked(pos.x, pos.y) && tries < 100);

        let type = 'normal';
        if (G.level >= 4 && Math.random() < 0.2) type = 'golden';

        G.food = { x: pos.x, y: pos.y, type, pulse: 0, timer: type === 'golden' ? 150 : null };
    }

    function spawnPowerUp() {
        if (G.powerUps.length >= 2 || Math.random() > 0.015) return;
        const types = [];
        if (G.level >= 2) types.push('speed');
        if (G.level >= 3) types.push('shield');
        if (G.level >= 8) types.push('ghost');
        if (types.length === 0) return;

        let pos, tries = 0;
        do {
            pos = { x: Math.floor(Math.random() * GRID), y: Math.floor(Math.random() * GRID) };
            tries++;
        } while (isBlocked(pos.x, pos.y) && tries < 50);

        G.powerUps.push({ x: pos.x, y: pos.y, type: types[Math.floor(Math.random() * types.length)], pulse: 0 });
    }

    function spawnObstacles(n) {
        for (let i = 0; i < n; i++) {
            let pos, tries = 0;
            do {
                pos = { x: Math.floor(Math.random() * (GRID-6)) + 3, y: Math.floor(Math.random() * (GRID-6)) + 3 };
                tries++;
            } while ((isBlocked(pos.x, pos.y) || isNearSnakeStart(pos.x, pos.y)) && tries < 50);
            G.obstacles.push(pos);
        }
    }

    function isNearSnakeStart(x, y) {
        if (Math.abs(x - 5) <= 3 && Math.abs(y - 15) <= 1) return true;
        if (Math.abs(x - 24) <= 3 && Math.abs(y - 15) <= 1) return true;
        return false;
    }

    function isBlocked(x, y) {
        if (G.snake.some(s => s.x === x && s.y === y)) return true;
        if (G.snake2.some(s => s.x === x && s.y === y)) return true;
        if (G.aiSnake.some(s => s.x === x && s.y === y)) return true;
        if (G.food && G.food.x === x && G.food.y === y) return true;
        if (G.obstacles.some(o => o.x === x && o.y === y)) return true;
        if (G.powerUps.some(p => p.x === x && p.y === y)) return true;
        return false;
    }

    function update() {
        if (G.paused) return;
        G.tick++;

        if (G.nextDir) { G.dir = G.nextDir; G.nextDir = null; }

        moveSnake(G.snake, G.dir, 1);

        if (G.mode === 'twoPlayer' && G.snake2.length > 0) {
            moveSnake(G.snake2, G.dir2, 2);
        }

        if (G.mode === 'ai' && G.aiSnake.length > 0) {
            updateAI();
            moveSnake(G.aiSnake, G.aiDir, 3);
        }

        spawnPowerUp();

        if (G.speed) { G.speedTime--; if (G.speedTime <= 0) G.speed = false; }
        if (G.ghost) { G.ghostTime--; if (G.ghostTime <= 0) G.ghost = false; }
        if (G.food && G.food.timer !== null) { G.food.timer--; if (G.food.timer <= 0) spawnFood(); }

        if ((G.mode === 'twoPlayer' || G.mode === 'ai') && G.score >= 200) endGame('Player 1 Wins!');
        if (G.mode === 'twoPlayer' && G.score2 >= 200) endGame('Player 2 Wins!');
        if (G.mode === 'ai' && G.aiScore >= 200) endGame('AI Wins!');

        updateUI();
    }

    function moveSnake(snake, dir, player) {
        if (snake.length === 0) return;

        const head = snake[0];
        const newHead = { x: head.x + dir.x, y: head.y + dir.y };

        if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID) {
            if (G.ghost && player === 1) {
                newHead.x = (newHead.x + GRID) % GRID;
                newHead.y = (newHead.y + GRID) % GRID;
            } else if (G.shield && player === 1) {
                G.shield = false;
                toast('Shield used!');
                return;
            } else {
                die(player);
                return;
            }
        }

        if (G.obstacles.some(o => o.x === newHead.x && o.y === newHead.y)) {
            if (G.ghost && player === 1) { }
            else if (G.shield && player === 1) { G.shield = false; toast('Shield used!'); return; }
            else { die(player); return; }
        }

        if (snake.slice(1).some(s => s.x === newHead.x && s.y === newHead.y)) {
            if (G.ghost && player === 1) { }
            else if (G.shield && player === 1) { G.shield = false; toast('Shield used!'); return; }
            else { die(player); return; }
        }

        const other = player === 1 ? (G.mode === 'twoPlayer' ? G.snake2 : G.aiSnake) : G.snake;
        if (other.some(s => s.x === newHead.x && s.y === newHead.y)) {
            die(player);
            return;
        }

        snake.unshift(newHead);

        if (player === 1) {
            const skin = SKINS[G.skin];
            if (skin.trail) {
                G.trails.push({ x: newHead.x * CELL + CELL/2, y: newHead.y * CELL + CELL/2, life: 1, color: skin.trailCol });
            }
        }

        if (G.food && newHead.x === G.food.x && newHead.y === G.food.y) {
            let pts = G.food.type === 'golden' ? 30 : 10;

            if (G.level >= 7) {
                if (G.lastFood === G.food.type) G.combo = Math.min(5, G.combo + 1);
                else G.combo = 1;
                G.lastFood = G.food.type;
            }
            pts *= G.combo;

            if (player === 1) G.score += pts;
            else if (player === 2) G.score2 += pts;
            else G.aiScore += pts;

            burst(G.food.x * CELL + CELL/2, G.food.y * CELL + CELL/2, G.food.type === 'golden' ? '#ffd700' : '#ff4444', 12);
            spawnFood();
        } else {
            snake.pop();
        }

        const pi = G.powerUps.findIndex(p => p.x === newHead.x && p.y === newHead.y);
        if (pi !== -1 && player === 1) {
            const pu = G.powerUps[pi];
            if (pu.type === 'speed') { G.speed = true; G.speedTime = 50; toast('Speed Boost!'); }
            else if (pu.type === 'shield') { G.shield = true; toast('Shield!'); }
            else if (pu.type === 'ghost') { G.ghost = true; G.ghostTime = 40; toast('Ghost Mode!'); }
            G.powerUps.splice(pi, 1);
            burst(newHead.x * CELL + CELL/2, newHead.y * CELL + CELL/2, '#00ccff', 15);
            G.combo = 1;
        }
    }

    function updateAI() {
        if (G.aiSnake.length === 0 || !G.food) return;
        const head = G.aiSnake[0];
        const dirs = [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}].filter(d => !(d.x === -G.aiDir.x && d.y === -G.aiDir.y));

        dirs.forEach(d => {
            const nx = head.x + d.x, ny = head.y + d.y;
            d.score = -Math.abs(nx - G.food.x) - Math.abs(ny - G.food.y);
            if (nx < 0 || nx >= GRID || ny < 0 || ny >= GRID) d.score -= 1000;
            if (G.aiSnake.some(s => s.x === nx && s.y === ny)) d.score -= 1000;
            if (G.snake.some(s => s.x === nx && s.y === ny)) d.score -= 1000;
            if (G.obstacles.some(o => o.x === nx && o.y === ny)) d.score -= 1000;
        });

        if (Math.random() < 0.1) {
            const valid = dirs.filter(d => d.score > -500);
            if (valid.length) { G.aiDir = valid[Math.floor(Math.random() * valid.length)]; return; }
        }

        dirs.sort((a,b) => b.score - a.score);
        if (dirs[0].score > -500) G.aiDir = {x: dirs[0].x, y: dirs[0].y};
    }

    function die(player) {
        if (player === 1) {
            G.snake.forEach(s => burst(s.x * CELL + CELL/2, s.y * CELL + CELL/2, '#ff4444', 5));
            if (G.mode === 'twoPlayer') { G.snake = []; endGame('Player 2 Wins!'); }
            else if (G.mode === 'ai') { G.snake = []; endGame('AI Wins!'); }
            else endGame('Game Over');
        } else if (player === 2) {
            G.snake2 = [];
            endGame('Player 1 Wins!');
        } else {
            G.aiSnake = [];
            endGame('Player 1 Wins!');
        }
    }

    function render() {
        if (!G.running) return;
        draw();
        animFrame = requestAnimationFrame(render);
    }

    function draw() {
        const theme = THEMES[G.theme];

        ctx.fillStyle = theme.bg;
        ctx.fillRect(0, 0, SIZE, SIZE);

        ctx.strokeStyle = theme.grid;
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID; i++) {
            ctx.beginPath(); ctx.moveTo(i*CELL, 0); ctx.lineTo(i*CELL, SIZE); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, i*CELL); ctx.lineTo(SIZE, i*CELL); ctx.stroke();
        }

        canvas.style.borderColor = theme.border;

        G.trails = G.trails.filter(t => {
            t.life -= 0.03;
            if (t.life > 0) {
                ctx.globalAlpha = t.life * 0.6;
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, 8 * t.life, 0, Math.PI * 2);
                ctx.fill();
                return true;
            }
            return false;
        });
        ctx.globalAlpha = 1;

        G.obstacles.forEach(o => {
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(o.x * CELL + 2, o.y * CELL + 2, CELL - 4, CELL - 4);
        });

        if (G.food) {
            G.food.pulse += 0.15;
            const scale = 1 + Math.sin(G.food.pulse) * 0.12;
            const col = G.food.type === 'golden' ? '#ffd700' : '#ff4444';

            ctx.shadowBlur = 12;
            ctx.shadowColor = col;
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.arc(G.food.x * CELL + CELL/2, G.food.y * CELL + CELL/2, (CELL/2 - 2) * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        G.powerUps.forEach(p => {
            p.pulse += 0.12;
            const scale = 1 + Math.sin(p.pulse) * 0.1;
            let col = '#ffff00';
            if (p.type === 'shield') col = '#00ccff';
            else if (p.type === 'ghost') col = '#9b59b6';

            ctx.shadowBlur = 10;
            ctx.shadowColor = col;
            ctx.fillStyle = col;
            const sz = (CELL - 4) * scale;
            ctx.fillRect(p.x * CELL + (CELL - sz)/2, p.y * CELL + (CELL - sz)/2, sz, sz);
            ctx.shadowBlur = 0;
        });

        drawSnake(G.snake, G.skin, G.ghost);
        if (G.snake2.length) drawSnake(G.snake2, 'classic', false, '#ff00ff');
        if (G.aiSnake.length) drawSnake(G.aiSnake, 'classic', false, '#ff6b6b');

        G.particles = G.particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.25;
            p.life -= 0.03;
            if (p.life > 0) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
                return true;
            }
            return false;
        });
        ctx.globalAlpha = 1;
    }

    function drawSnake(snake, skinId, transparent, override) {
        if (snake.length === 0) return;
        const skin = SKINS[skinId] || SKINS.classic;
        const baseAlpha = transparent ? 0.5 : 1;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        for (let i = snake.length - 1; i >= 1; i--) {
            const curr = snake[i];
            const prev = snake[i - 1];
            const progress = i / snake.length;
            const alpha = baseAlpha * (1 - progress * 0.35);

            let col;
            if (override) col = override;
            else if (skinId === 'rainbow') col = skin.colors[(i + G.tick) % skin.colors.length];
            else col = skin.colors[Math.min(Math.floor(progress * (skin.colors.length - 1)), skin.colors.length - 1)];

            ctx.globalAlpha = alpha;
            ctx.strokeStyle = col;
            ctx.lineWidth = CELL - 4;
            ctx.beginPath();
            ctx.moveTo(prev.x * CELL + CELL/2, prev.y * CELL + CELL/2);
            ctx.lineTo(curr.x * CELL + CELL/2, curr.y * CELL + CELL/2);
            ctx.stroke();

            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.arc(curr.x * CELL + CELL/2, curr.y * CELL + CELL/2, (CELL - 4)/2, 0, Math.PI * 2);
            ctx.fill();
        }

        const head = snake[0];
        const headCol = override || skin.colors[0];

        ctx.globalAlpha = baseAlpha;
        ctx.shadowBlur = 15;
        ctx.shadowColor = override || skin.glow;
        ctx.fillStyle = headCol;
        ctx.beginPath();
        ctx.arc(head.x * CELL + CELL/2, head.y * CELL + CELL/2, CELL/2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#000';
        const dir = snake === G.snake ? G.dir : (snake === G.snake2 ? G.dir2 : G.aiDir);
        let e1x, e1y, e2x, e2y;
        const hx = head.x * CELL + CELL/2, hy = head.y * CELL + CELL/2;

        if (dir.x === 1) { e1x = e2x = hx + 4; e1y = hy - 4; e2y = hy + 4; }
        else if (dir.x === -1) { e1x = e2x = hx - 4; e1y = hy - 4; e2y = hy + 4; }
        else if (dir.y === 1) { e1y = e2y = hy + 4; e1x = hx - 4; e2x = hx + 4; }
        else { e1y = e2y = hy - 4; e1x = hx - 4; e2x = hx + 4; }

        ctx.beginPath();
        ctx.arc(e1x, e1y, 3, 0, Math.PI * 2);
        ctx.arc(e2x, e2y, 3, 0, Math.PI * 2);
        ctx.fill();

        if (G.shield && snake === G.snake) {
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ccff';
            ctx.beginPath();
            ctx.arc(hx, hy, CELL/2 + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        ctx.globalAlpha = 1;
    }

    function burst(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            G.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8 - 2,
                color,
                life: 1,
                size: Math.random() * 4 + 2
            });
        }
    }

    function updateUI() {
        document.getElementById('score').textContent = G.score;
        document.getElementById('length').textContent = G.snake.length;
        document.getElementById('combo').textContent = G.combo + 'x';
        document.getElementById('combo').style.color = G.combo >= 3 ? '#ff8800' : '#00ff88';

        let powers = '';
        if (G.speed) powers += '<div style="color:#ffff00">Speed!</div>';
        if (G.shield) powers += '<div style="color:#00ccff">Shield</div>';
        if (G.ghost) powers += '<div style="color:#9b59b6">Ghost</div>';
        document.getElementById('powerDisplay').innerHTML = powers;
    }

    function togglePause() {
        if (!G.running) return;
        G.paused = !G.paused;
        if (G.paused) toast('PAUSED');
    }

    function quitGame() {
        G.running = false;
        clearInterval(gameInterval);
        cancelAnimationFrame(animFrame);
        document.getElementById('gameScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'block';
        customWalls = [];
        updateMenu();
    }

    function endGame(msg) {
        G.running = false;
        clearInterval(gameInterval);
        cancelAnimationFrame(animFrame);

        const xpEarned = Math.floor(G.score / 5);
        const coinsEarned = Math.floor(G.score / 10);
        G.xp += xpEarned;
        G.coins += coinsEarned;
        if (G.score > G.highScore) G.highScore = G.score;

        let leveled = false;
        while (G.level < 20 && G.xp >= LEVEL_XP[G.level]) {
            G.level++;
            leveled = true;
        }
        save();

        document.getElementById('gameOverTitle').textContent = msg;
        document.getElementById('gameOverStats').innerHTML = `
            <div class="stat-row"><span>Score</span><span>${G.score}</span></div>
            <div class="stat-row"><span>Length</span><span>${G.snake.length || 0}</span></div>
            <div class="stat-row"><span>XP Earned</span><span>+${xpEarned}</span></div>
            <div class="stat-row"><span>Coins</span><span>+${coinsEarned}</span></div>
        `;
        document.getElementById('gameOverModal').style.display = 'flex';

        if (leveled) {
            setTimeout(() => {
                document.getElementById('gameOverModal').style.display = 'none';
                showLevelUp();
            }, 1500);
        }
    }

    function closeGameOver() {
        document.getElementById('gameOverModal').style.display = 'none';
        quitGame();
    }

    function showLevelUp() {
        document.getElementById('newLevel').textContent = G.level;
        const u = UNLOCKS[G.level];
        document.getElementById('unlockInfo').innerHTML = u
            ? `<span style="font-size:2em">${u.icon}</span><br><strong>${u.name}</strong><br>${u.desc}`
            : 'Keep playing!';
        document.getElementById('levelUpModal').style.display = 'flex';
    }

    function closeLevelUp() {
        document.getElementById('levelUpModal').style.display = 'none';
        quitGame();
    }

    function openCustomize() {
        renderSkins();
        renderThemes();
        document.getElementById('customModal').style.display = 'flex';
    }

    function closeCustomize() {
        document.getElementById('customModal').style.display = 'none';
        updateSkinPreview();
        save();
    }

    function renderSkins() {
        const grid = document.getElementById('skinGrid');
        grid.innerHTML = '';
        Object.entries(SKINS).forEach(([id, s]) => {
            const unlocked = G.level >= s.lvl;
            const sel = G.skin === id;
            const div = document.createElement('div');
            div.className = `skin-opt ${sel ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
            div.innerHTML = `
                <div class="skin-bar" style="background:linear-gradient(90deg,${s.colors.join(',')});box-shadow:0 0 8px ${s.glow}"></div>
                <div class="skin-name">${s.name}</div>
                ${!unlocked ? `<div class="skin-lvl">Lvl ${s.lvl}</div>` : ''}
            `;
            if (unlocked) div.onclick = () => { G.skin = id; renderSkins(); toast(s.name + ' selected!'); };
            grid.appendChild(div);
        });
    }

    function renderThemes() {
        const grid = document.getElementById('themeGrid');
        grid.innerHTML = '';
        Object.entries(THEMES).forEach(([id, t]) => {
            const unlocked = G.level >= t.lvl;
            const sel = G.theme === id;
            const div = document.createElement('div');
            div.className = `skin-opt ${sel ? 'selected' : ''} ${!unlocked ? 'locked' : ''}`;
            div.innerHTML = `
                <div style="width:60px;height:35px;margin:5px auto;background:${t.bg};border:2px solid ${t.border};border-radius:4px"></div>
                <div class="skin-name">${t.name}</div>
                ${!unlocked ? `<div class="skin-lvl">Lvl ${t.lvl}</div>` : ''}
            `;
            if (unlocked) div.onclick = () => { G.theme = id; renderThemes(); toast(t.name + ' selected!'); };
            grid.appendChild(div);
        });
    }

    function toast(msg) {
        const t = document.createElement('div');
        t.className = 'toast';
        t.textContent = msg;
        document.body.appendChild(t);
        setTimeout(() => t.remove(), 2500);
    }

    function setupEditor() {
        let drawing = false;
        editorCanvas.addEventListener('mousedown', e => { drawing = true; editorDraw(e); });
        editorCanvas.addEventListener('mousemove', e => { if (drawing) editorDraw(e); });
        editorCanvas.addEventListener('mouseup', () => drawing = false);
        editorCanvas.addEventListener('mouseleave', () => drawing = false);
        editorCanvas.addEventListener('contextmenu', e => e.preventDefault());
    }

    function editorDraw(e) {
        const rect = editorCanvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / CELL);
        const y = Math.floor((e.clientY - rect.top) / CELL);
        if (x < 0 || x >= GRID || y < 0 || y >= GRID) return;

        if (editorTool === 'wall' && e.buttons === 1) {
            if (!editorWalls.some(w => w.x === x && w.y === y) && !isNearSnakeStart(x, y)) {
                editorWalls.push({x, y});
            }
        } else if (editorTool === 'erase' || e.buttons === 2) {
            editorWalls = editorWalls.filter(w => !(w.x === x && w.y === y));
        }
        drawEditor();
    }

    function drawEditor() {
        const theme = THEMES[G.theme];
        editorCtx.fillStyle = theme.bg;
        editorCtx.fillRect(0, 0, SIZE, SIZE);

        editorCtx.strokeStyle = theme.grid;
        for (let i = 0; i <= GRID; i++) {
            editorCtx.beginPath(); editorCtx.moveTo(i*CELL, 0); editorCtx.lineTo(i*CELL, SIZE); editorCtx.stroke();
            editorCtx.beginPath(); editorCtx.moveTo(0, i*CELL); editorCtx.lineTo(SIZE, i*CELL); editorCtx.stroke();
        }

        editorCtx.fillStyle = '#8b4513';
        editorWalls.forEach(w => editorCtx.fillRect(w.x*CELL+2, w.y*CELL+2, CELL-4, CELL-4));

        editorCtx.fillStyle = 'rgba(0,255,136,0.2)';
        editorCtx.fillRect(2*CELL, 14*CELL, 7*CELL, 3*CELL);
        editorCtx.fillStyle = 'rgba(255,0,255,0.2)';
        editorCtx.fillRect(21*CELL, 14*CELL, 7*CELL, 3*CELL);
    }

    function openEditor() {
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('editorScreen').style.display = 'block';
        editorWalls = [];
        drawEditor();
    }

    function closeEditor() {
        document.getElementById('editorScreen').style.display = 'none';
        document.getElementById('mainMenu').style.display = 'block';
    }

    function testLevel() {
        customWalls = editorWalls.map(w => ({...w}));
        document.getElementById('editorScreen').style.display = 'none';
        startGame('classic');
    }

    window.onload = init;
    </script>
</body>
</html>
